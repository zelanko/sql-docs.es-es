---
title: Función SQLSetStmtAttr | Documentos de Microsoft
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: drivers
ms.service: ''
ms.component: odbc
ms.reviewer: ''
ms.suite: sql
ms.technology:
- drivers
ms.tgt_pltfrm: ''
ms.topic: article
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
caps.latest.revision: 32
author: MightyPen
ms.author: genemi
manager: craigg
ms.workload: On Demand
ms.openlocfilehash: fab28d7076d4a529b1b77a340deb2f2e411da334
ms.sourcegitcommit: 7a6df3fd5bea9282ecdeffa94d13ea1da6def80a
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 04/16/2018
---
# <a name="sqlsetstmtattr-function"></a>Función SQLSetStmtAttr
**Conformidad**  
 Versión introdujo: ODBC 3.0 normativas: ISO 92  
  
 **Resumen**  
 **SQLSetStmtAttr** establece atributos relacionados con una instrucción.  
  
> [!NOTE]  
>  Para obtener más información sobre lo que el Administrador de controladores se asigna esta función cuando una aplicación ODBC 3*.x* aplicación está trabajando con una API ODBC 2*.x* controladores, consulte [asignación de funciones de reemplazo para hacia atrás Compatibilidad de las aplicaciones](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxis  
  
```  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 [Entrada] Identificador de instrucción.  
  
 *Atributo*  
 [Entrada] Opción para establecer, aparecen en "Comentarios".  
  
 *ValuePtr*  
 [Entrada] Valor que se asociará con *atributo*. Dependiendo del valor de *atributo*, *ValuePtr* será uno de los siguientes:  
  
-   Un identificador de descriptor ODBC.  
  
-   Un valor SQLUINTEGER.  
  
-   Un valor SQLULEN.  
  
-   Un puntero a uno de los siguientes:  
  
    -   Una cadena de caracteres terminada en null.  
  
    -   Un búfer binario.  
  
    -   Un valor o una matriz de tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Un valor definido por el controlador.  
  
 Si el *atributo* argumento es un valor específico del controlador, *ValuePtr* puede ser un entero con signo.  
  
 *stringLength*  
 [Entrada] Si *atributo* es un atributo definido en ODBC y *ValuePtr* apunta a una cadena de caracteres o un búfer binario, este argumento debe ser la longitud de \* *ValuePtr*. Si *atributo* es un atributo definido en ODBC y *ValuePtr* es un entero, *StringLength* se omite.  
  
 Si *atributo* es un atributo definido por el controlador, la aplicación indica la naturaleza del atributo para el Administrador de controladores al establecer el *StringLength* argumento. *StringLength* puede tener los valores siguientes:  
  
-   Si *ValuePtr* es un puntero a una cadena de caracteres, a continuación, *StringLength* es la longitud de la cadena o SQL_NTS.  
  
-   Si *ValuePtr* es un puntero a un búfer binario, a continuación, la aplicación coloca el resultado de la SQL_LEN_BINARY_ATTR (*longitud*) macro en *StringLength*. Esto coloca un valor negativo en *StringLength*.  
  
-   Si *ValuePtr* es un puntero a un valor distinto de una cadena de caracteres o una cadena binaria, a continuación, *StringLength* debería tener el valor SQL_IS_POINTER.  
  
-   Si *ValuePtr* contiene un valor de longitud fija, a continuación, *StringLength* es SQL_IS_INTEGER o SQL_IS_UINTEGER, según corresponda.  
  
## <a name="returns"></a>Devuelve  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnósticos  
 Cuando **SQLSetStmtAttr** devuelve SQL_ERROR o SQL_SUCCESS_WITH_INFO, un valor SQLSTATE asociado se puede obtener mediante una llamada a **SQLGetDiagRec** con un *HandleType* de SQL _HANDLE_STMT y un *controlar* de *StatementHandle*. En la tabla siguiente se enumera los valores SQLSTATE devueltos normalmente por **SQLSetStmtAttr** y se explica cada uno de ellos en el contexto de esta función; la notación "(DM)" precede a las descripciones de SQLSTATE devuelto por el Administrador de controladores. El código de retorno asociado a cada valor SQLSTATE es SQL_ERROR, a menos que se indique lo contrario.  
  
|SQLSTATE|Error|Description|  
|--------------|-----------|-----------------|  
|01000|Advertencia general|Mensaje informativo de específicas del controlador. (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|01S02|Ha cambiado el valor de opción|El controlador no admitía el valor especificado en *ValuePtr*, o el valor especificado en *ValuePtr* no era válido debido a las condiciones de trabajo de implementación, por lo que el controlador sustituye un valor similar. (**SQLGetStmtAttr** se puede llamar para determinar el valor sustituido temporalmente.) El valor de reemplazo es válido para la *StatementHandle* hasta que se cierra el cursor, momento en que el atributo de instrucción revierte a su valor anterior. Los atributos de instrucción que se pueden cambiar son:<br /><br /> ATTR_CONCURRENCY SQL_ SQL_ SQL_ ATTR_CURSOR_TYPE ATTR_KEYSET_SIZE ATTR_MAX_LENGTH SQL_ SQL_ SQL_ ATTR_MAX_ROWS ATTR_QUERY_TIMEOUT SQL_ SQL_ATTR_ROW_ARRAY_SIZE ATTR_SIMULATE_CURSOR<br /><br /> (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|08S01|Error de vínculo de comunicación|El vínculo de comunicación entre el controlador y el origen de datos al que se conectó el controlador no pudo antes del procesamiento de la función se ha completado.|  
|24000|Estado de cursor no válido|El *atributo* era SQL_ATTR_CURSOR_TYPE, SQL_ATTR_CONCURRENCY, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS y abrió el cursor.|  
|HY000|Error general|Se produjo un error para que no hubo ninguna SQLSTATE específico y para el que se ha definido ningún SQLSTATE específico de la implementación. El mensaje de error devuelto por **SQLGetDiagRec** en el  *\*MessageText* búfer describe el error y su causa.|  
|HY001|Error de asignación de memoria|El controlador no pudo asignar la memoria necesaria para admitir la ejecución o la finalización de la función.|  
|HY009|Uso no válido del puntero null|El *atributo* argumento identifica un atributo de instrucción que requiere un atributo de cadena, y el *ValuePtr* argumento era un puntero nulo.|  
|HY010|Error de secuencia de función|(DM) se llamó a una función ejecuta de forma asincrónica para el identificador de conexión que está asociado el *StatementHandle*. Esta función asincrónica aún estaba ejecutando cuando el **SQLSetStmtAttr** se llamó la función.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, o **SQLMoreResults** se llamó para el *StatementHandle* devolvió SQL_PARAM_DATA_ ESTÁ DISPONIBLE. Esta función se invoca antes de que se recuperan los datos para todos los parámetros transmitidos.<br /><br /> (DM) se llamó a una función ejecuta de forma asincrónica para la *StatementHandle* y aún se estaba ejecutando cuando se llamó a esta función.<br /><br /> (DM) **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**, o **SQLSetPos** se llamó para el  *StatementHandle* y devuelve SQL_NEED_DATA. Esta función se invoca antes de que se enviaron los datos para todas las columnas o parámetros de datos en ejecución.|  
|HY011|Atributo no se puede establecer ahora|El *atributo* fue SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR o SQL_ ATTR_USE_BOOKMARKS, y se ha preparado la instrucción.|  
|HY013|Error de administración de memoria|No se pudo procesar la llamada de función porque los objetos subyacentes de la memoria no se pudieron tener acceso, posiblemente debido a condiciones de memoria insuficiente.|  
|HY017|Uso no válido de un identificador de descriptor asignado automáticamente|(DM) la *atributo* argumento era SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) la *atributo* argumento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC y el valor de *ValuePtr* era originalmente un identificador de descriptor asignado implícitamente que no sea el identificador asigna el descartar o APD.|  
|HY024|Valor de atributo no válido|Dada la especificado *atributo* valor, que se especificó un valor no válido en *ValuePtr*. (El Administrador de controladores devuelve este valor de SQLSTATE solo para la conexión y los atributos de instrucción que aceptan un conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE o SQL_ ATTR_ASYNC_ENABLE. Para el resto de conexión y los atributos de instrucción, el controlador debe comprobar el valor especificado en *ValuePtr*.)<br /><br /> El *atributo* argumento era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC, y *ValuePtr* era un identificador de descriptor asignado explícitamente que no está en la misma conexión que la  *StatementHandle* argumento.|  
|HY090|Longitud de búfer o cadena no válida|(DM)  *\*ValuePtr* es una cadena de caracteres y la *StringLength* argumento era menor que 0 pero no SQL_NTS.|  
|HY092|Identificador de opción o atributo no válido|(DM) el valor especificado para el argumento *atributo* no era válido para la versión de ODBC compatible con el controlador.<br /><br /> (DM) el valor especificado para el argumento *atributo* era un atributo de sólo lectura.|  
|HY117|Se suspende la conexión debido al estado de transacción desconocido. Solo se desconecte y se permiten las funciones de solo lectura.|(DM) para obtener más información sobre el estado suspendido, consulte [función SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Característica opcional no implementada|El valor especificado para el argumento *atributo* era un atributo de instrucción ODBC válido para el controlador es compatible con la versión de ODBC, pero no era compatible con el controlador.<br /><br /> El *atributo* argumento era SQL_ATTR_ASYNC_ENABLE y una llamada a **SQLGetInfo** con una *tipo de información* de SQL_ASYNC_MODE devuelve SQL_AM_CONNECTION.<br /><br /> El *atributo* argumento era SQL_ATTR_ENABLE_AUTO_IPD y el valor del atributo de conexión SQL_ATTR_AUTO_IPD era SQL_FALSE.|  
|HYT01|Tiempo de espera de conexión expirado|El período de tiempo de espera de conexión finalizó antes de que el origen de datos se respondió a la solicitud. El período de tiempo de espera de conexión se establece a través de **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|Controlador no admite esta función|(DM) el controlador asociado a la *StatementHandle* no admite la función.|  
|S1118|Controlador no admite la notificación asincrónica|Si una llamada a **SQLSetStmtAttr** establecer SQL_ATTR_ASYNC_STMT_EVENT; notificación asincrónica no es compatible con el controlador.|  
  
## <a name="comments"></a>Comentarios  
 Atributos de instrucción para una instrucción sigue surtiendo efecto hasta que se cambian por otra llamada a **SQLSetStmtAttr** o hasta que la instrucción se quita mediante una llamada a **SQLFreeHandle**. Al llamar a **SQLFreeStmt** con SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS opción no restablece los atributos de instrucción.  
  
 Algunos atributos de instrucción admiten la sustitución de un valor similar si el origen de datos no es compatible con el valor especificado en *ValuePtr*. En tales casos, el controlador devuelve SQL_SUCCESS_WITH_INFO y SQLSTATE 01S02 de SQLState (valor de opción cambiado). Por ejemplo, si *atributo* es SQL_ATTR_CONCURRENCY y *ValuePtr* es SQL_CONCUR_ROWVER, y si el origen de datos no es compatible con esto, el controlador sustituye SQL_CONCUR_VALUES y devuelve SQL_ SUCCESS_WITH_INFO. Para determinar el valor sustituido, llama a una aplicación **SQLGetStmtAttr**.  
  
 Establece el formato de información con *ValuePtr* depende especificado *atributo*. **SQLSetStmtAttr** acepta información de atributo en uno de los dos formatos diferentes: una cadena de caracteres o un valor entero. El formato de cada uno se indica en la descripción del atributo. Este formato se aplica a la información devuelta para cada atributo de **SQLGetStmtAttr**. Caracteres de cadenas que señala el *ValuePtr* argumento de **SQLSetStmtAttr** tienen una longitud de *StringLength*.  
  
> [!NOTE]  
>  Permite establecer atributos de instrucción en el nivel de conexión mediante una llamada a **SQLSetConnectAttr** está en desuso en ODBC 3*.x*. ODBC 3*.x* aplicaciones nunca deben establecer los atributos de instrucción en el nivel de conexión. ODBC 3*.x* atributos de instrucción no se puede establecer en el nivel de conexión, a excepción de los atributos SQL_ATTR_METADATA_ID y SQL_ATTR_ASYNC_ENABLE, que son atributos de conexión y los atributos de instrucción y puede ser Establezca en el nivel de conexión o en el nivel de instrucción.  
  
> [!NOTE]  
>  ODBC 3*.x* controladores sólo necesitan admitir esta funcionalidad si deben trabajar con ODBC 2*.x* aplicación que establezca ODBC 2*.x* opciones de la instrucción en el nivel de conexión. Para obtener más información, consulte "Configuración de opciones en la conexión de nivel de instrucción" en [SQLSetConnectOption asignación](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) en Apéndice G: controlador directrices para la compatibilidad con versiones anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrucción que establecer campos de Descriptor  
 Muchos de los atributos de instrucción corresponden a un campo de encabezado de un descriptor. Establecer estos atributos realmente los resultados en la configuración de los campos de descriptor. Establecer campos de mediante una llamada a **SQLSetStmtAttr** en lugar de a **SQLSetDescField** tiene la ventaja de que no tiene un identificador de descriptor que obtenerse para que la llamada de función.  
  
> [!CAUTION]  
>  Al llamar a **SQLSetStmtAttr** para una instrucción puede afectar a otras instrucciones. Esto se produce cuando el APD o descartar asociados con la instrucción se asigna explícitamente y también está asociado con otras instrucciones. Dado que **SQLSetStmtAttr** modifica el APD o descartar, las modificaciones se aplican a todas las instrucciones con el que está asociado este descriptor. Si no es el comportamiento requerido, la aplicación debe anular la asociación de este descriptor de las demás instrucciones (mediante una llamada a **SQLSetStmtAttr** para establecer el campo SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC a otra identificador de descriptor) antes de llamar a **SQLSetStmtAttr** nuevo.  
  
 Cuando un campo descriptor se establece como resultado que se va a establecer el atributo de instrucción correspondiente, el campo solo se establece para los descriptores de aplicable que están asociados actualmente con la instrucción identificada por la *StatementHandle* argumento y el valor de atributo no afecta a los descriptores que puedan estar asociados con esa instrucción en el futuro. Cuando un campo de descriptor que también es un atributo de instrucción se establece mediante una llamada a **SQLSetDescField**, se establece el atributo de instrucción correspondiente. Si un descriptor asignado explícitamente es disociar de una instrucción, un atributo de instrucción que corresponde a un campo de encabezado se restablecerá el valor del campo en el descriptor asignado implícitamente.  
  
 Cuando se asigna una instrucción (consulte [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), cuatro identificadores de descriptor automáticamente asignados y asociados a la instrucción. Identificadores de descriptor asignado explícitamente se pueden asociadas con la instrucción mediante una llamada a **SQLAllocHandle** con una *fHandleType* de SQL_HANDLE_DESC para asignar un identificador de descriptor y, a continuación, llamar a  **SQLSetStmtAttr** para asociar el identificador de descriptor de la instrucción.  
  
 Los atributos de instrucción en la siguiente tabla se corresponden a los campos de encabezado de descriptor.  
  
|Atributo de instrucción|Campo de encabezado|Desc.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|DESCARTAR|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|DESCARTAR|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|DESCARTAR|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|DESCARTAR|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Atributos de instrucción  
 Se muestran los atributos definidos actualmente y la versión de ODBC en el que se introdujeron en la siguiente tabla. se espera que se definirán atributos más controladores para aprovechar las ventajas de diferentes orígenes de datos. Un intervalo de atributos está reservado por ODBC; los desarrolladores de controladores deben reservar los valores para su propio uso específicos del controlador de Open Group. Para obtener más información, consulte [tipos de datos específicos del controlador, Descriptor de tipos, información de tipos, tipos de diagnóstico y atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Atributo|*ValuePtr* contenido|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3.0)|El identificador para el APD para llamadas posteriores a **SQLExecute** y **SQLExecDirect** en el identificador de instrucción. El valor inicial de este atributo es el descriptor asignado implícitamente cuando la instrucción se asignó inicialmente. Si el valor de este atributo se establece en SQL_NULL_DESC o bien el controlador que se asignó originalmente para el descriptor, un identificador asignado explícitamente al APD que estaba asociado previamente con el identificador de instrucción se desasoció de él y el identificador de instrucción vuelve a la asigna implícitamente identificador APD.<br /><br /> Este atributo no puede establecerse en un identificador de descriptor que se asignó implícitamente a otra instrucción o a otro identificador de descriptor que se establece implícitamente en la misma instrucción; identificadores de descriptor asignado implícitamente no pueden asociarse con más de una instrucción o identificador de descriptor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3.0)|El identificador para el Descartar para las capturas siguientes en el identificador de instrucción. El valor inicial de este atributo es el descriptor asignado implícitamente cuando la instrucción se asignó inicialmente. Si el valor de este atributo se establece en SQL_NULL_DESC o bien el controlador que se asignó originalmente para el descriptor, un identificador asignado explícitamente al descartar que estaba asociado previamente con el identificador de instrucción se desasoció de él y el identificador de instrucción vuelve a la asigna implícitamente identificador descartar.<br /><br /> Este atributo no puede establecerse en un identificador de descriptor que se asignó implícitamente a otra instrucción o a otro identificador de descriptor que se establece implícitamente en la misma instrucción; identificadores de descriptor asignado implícitamente no pueden asociarse con más de una instrucción o identificador de descriptor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1.0)|Un valor SQLULEN que especifica si llama a una función con la instrucción especificada se ejecuta de forma asincrónica:<br /><br /> SQL_ASYNC_ENABLE_OFF = soporte de nivel de ejecución asincrónica de instrucción Disable (valor predeterminado).<br /><br /> SQL_ASYNC_ENABLE_ON = Habilitar soporte de nivel de ejecución asincrónica de instrucción.<br /><br /> Para obtener más información, consulte [ejecución asincrónica (método de sondeo)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> Para los controladores con el soporte técnico de nivel de ejecución asincrónica de instrucción, el atributo de instrucción SQL_ATTR_ASYNC_ENABLE es de solo lectura. Su valor es el mismo que el valor del atributo de nivel de conexión con el mismo nombre en el momento en que se asignó el identificador de instrucción.<br /><br /> Al llamar a **SQLSetStmtAttr** para establecer SQL_ATTR_ASYNC_ENABLE cuando la SQL_ASYNC_MODE *tipo de información* devuelve SQL_AM_CONNECTION devuelve SQLSTATE HYC00 (característica opcional no implementada). Para obtener más información, consulte [función SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) para obtener más información.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3.8)|Un valor SQLPOINTER es un identificador de evento.<br /><br /> Notificación de finalización de funciones asincrónicas está habilitada mediante una llamada a **SQLSetStmtAttr** para establecer el **SQL_ATTR_ASYNC_STMT_EVENT** de atributo y especificar el controlador de eventos.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3.8)|Un SQLPOINTER a la función de devolución de llamada asincrónica.<br /><br /> Solo el Administrador de controladores puede llamar a un controlador **SQLSetStmtAttr** función con este atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3.8)|Un SQLPOINTER a la estructura de contexto<br /><br /> Solo el Administrador de controladores puede llamar a un controlador **SQLSetStmtAttr** función con este atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2.0)|Un valor SQLULEN que especifica la simultaneidad de cursor:<br /><br /> SQL_CONCUR_READ_ONLY = Cursor es de solo lectura. No se permiten actualizaciones.<br /><br /> SQL_CONCUR_LOCK = Cursor usará el nivel más bajo de bloqueo suficiente para asegurarse de que se puede actualizar la fila.<br /><br /> SQL_CONCUR_ROWVER = Cursor utiliza control de simultaneidad optimista, comparar las versiones de fila como SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = Cursor utiliza control de simultaneidad optimista, comparar los valores.<br /><br /> El valor predeterminado de SQL_ATTR_CONCURRENCY es SQL_CONCUR_READ_ONLY.<br /><br /> No se especifica este atributo para un cursor abierto. Para obtener más información, consulte [tipos de simultaneidad](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si el SQL_ATTR_CURSOR_TYPE *atributo* se cambia a un tipo que no es compatible con el valor actual de SQL_ATTR_CONCURRENCY, se cambiará el valor de SQL_ATTR_CONCURRENCY en tiempo de ejecución y emite una advertencia cuando **SQLExecDirect** o **SQLPrepare** se llama.<br /><br /> Si el controlador admite la **SELECT FOR UPDATE** instrucción y una instrucción se ejecuta mientras se establece el valor de SQL_ATTR_CONCURRENCY en SQL_CONCUR_READ_ONLY, se devolverá un error. Si se cambia el valor de SQL_ATTR_CONCURRENCY a un valor que admite el controlador para algún valor de SQL_ATTR_CURSOR_TYPE pero no para el valor actual de SQL_ATTR_CURSOR_TYPE, se cambiará el valor de SQL_ATTR_CURSOR_TYPE en tiempo de ejecución y 01S02 SQLSTATE (Se ha cambiado el valor de opción) se emite cuando **SQLExecDirect** o **SQLPrepare** se llama.<br /><br /> Si la simultaneidad especificada no es compatible con el origen de datos, el controlador sustituye una simultaneidad distinta y devuelve 01S02 SQLSTATE (valor de opción cambiado). Para SQL_CONCUR_VALUES, el controlador sustituye SQL_CONCUR_ROWVER y viceversa. En el caso de SQL_CONCUR_LOCK, el controlador pasa, en orden, SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES. No se comprueba la validez del valor sustituido hasta el tiempo de ejecución.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CONCURRENCY y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3.0)|Un valor SQLULEN que especifica el nivel de compatibilidad que necesita la aplicación. Al establecer este atributo afecta a las llamadas subsiguientes a **SQLExecDirect** y **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = Scrollable los cursores no son obligatorios en el identificador de instrucción. Si la aplicación llama **SQLFetchScroll** en este identificador, el único valor válido de *FetchOrientation* es SQL_FETCH_NEXT. Ésta es la opción predeterminada.<br /><br /> SQL_SCROLLABLE = Scrollable cursores son obligatorios en el identificador de instrucción. Al llamar a **SQLFetchScroll**, la aplicación puede especificar cualquier valor válido de *FetchOrientation*, para lograr el posicionamiento de cursor en modos que no sean el modo secuencial.<br /><br /> Para obtener más información acerca de los cursores desplazables, consulte [cursores desplazables](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SCROLLABLE y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md)|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3.0)|Un valor SQLULEN que especifica si los cursores en el identificador de instrucción hacer visibles los cambios realizados en un resultado establecen por otro cursor. Al establecer este atributo afecta a las llamadas subsiguientes a **SQLExecDirect** y **SQLExecute**. Una aplicación puede leer de nuevo el valor de este atributo para obtener su estado inicial o su estado como más recientemente establecidos por la aplicación.<br /><br /> SQL_UNSPECIFIED = no se especifica cuál es el tipo de cursor y si los cursores en el identificador de instrucción hacer que sean visibles los cambios realizados en un conjunto de resultados por otro cursor. Los cursores en el identificador de instrucción pueden hacer visible ninguno, algunos o todos estos cambios. Ésta es la opción predeterminada.<br /><br /> SQL_INSENSITIVE = todos los cursores de la presentación de identificador de instrucción del conjunto de resultados sin reflejar los cambios realizados en él por cualquier otro cursor. Los cursores son de solo lectura. Esto corresponde a un cursor estático, que tiene una simultaneidad que es de solo lectura.<br /><br /> SQL_SENSITIVE = todos los cursores de la marca de identificador de instrucción que visibles todos los cambios realizados a un resultado de establecen otro cursor.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SENSITIVITY y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2.0)|Un valor SQLULEN que especifica el tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = el cursor solo se desplaza hacia delante.<br /><br /> SQL_CURSOR_STATIC = los datos en el resultado de conjunto es estático.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = el controlador guarda y utiliza las claves para el número de filas especificado en el atributo de instrucción SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = el controlador guarda y usa solo las claves para las filas del conjunto de filas.<br /><br /> El valor predeterminado es SQL_CURSOR_FORWARD_ONLY. Este atributo no se puede especificar una vez se ha preparado la instrucción SQL.<br /><br /> Si el tipo de cursor especificado no es compatible con el origen de datos, el controlador sustituye otro tipo de cursor y devuelve 01S02 SQLSTATE (valor de opción cambiado). Para un cursor dinámico o mixto, el controlador sustituye, en orden, un cursor controlado por conjunto de claves o estático. Para un cursor controlado por conjunto de claves, el controlador sustituye un cursor estático.<br /><br /> Para obtener más información acerca de los tipos de cursor desplazable, consulte [tipos de Cursor desplazable](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_TYPE y otros atributos de cursor, vea [características del Cursor y el tipo de Cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3.0)|Un valor SQLULEN que especifica si se realiza el rellenado automático de la IPD:<br /><br /> SQL_TRUE = activa en el rellenado automático de la IPD después de llamar a **SQLPrepare**. SQL_FALSE = activa desactivar el rellenado automático de la IPD después de llamar a **SQLPrepare**. (Una aplicación todavía puede obtener información de los campos IPD mediante una llamada a **SQLDescribeParam**, si compatible.) El valor predeterminado del atributo de instrucción SQL_ATTR_ENABLE_AUTO_IPD es SQL_FALSE. Para obtener más información, consulte [el rellenado automático de la IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3.0)|Un SQLLEN \* que apunta a un valor binario de marcador. Cuando **SQLFetchScroll** se llama con *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, el controlador recoge el valor de marcador de este campo. El valor predeterminado de este campo es un puntero nulo. Para obtener más información, consulte [desplazamiento por marcador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> El valor al que apunta este campo no se utiliza para eliminar marcador, actualizar por marcador o capturar las operaciones de marcador de **SQLBulkOperations**, que utilice marcadores almacenados en memoria caché de búferes de conjunto de filas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3.0)|El identificador para el IPD. El valor de este atributo es el descriptor asignado cuando la instrucción se asignó inicialmente. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no se establece mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3.0)|El identificador de IRD. El valor de este atributo es el descriptor asignado cuando la instrucción se asignó inicialmente. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no se establece mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2.0)|Un SQLULEN que especifica el número de filas en el conjunto de claves de un cursor controlado por conjunto de claves. Si el tamaño del conjunto de claves es 0 (valor predeterminado), el cursor está completamente controlados por conjunto de claves. Si el tamaño del conjunto de claves es mayor que 0, el cursor es mixto (controlado por conjunto de claves en el conjunto de claves y dinámicos fuera el conjunto de claves). El tamaño del conjunto de claves predeterminado es 0. Para obtener más información acerca de los cursores controlados por conjunto de claves, consulte [cursores dinámicos](../../../odbc/reference/develop-app/keyset-driven-cursors.md).<br /><br /> Si el tamaño especificado supera el tamaño máximo del conjunto de claves, el controlador sustituye ese tamaño y devuelve 01S02 SQLSTATE (valor de opción cambiado).<br /><br /> **SQLFetch** o **SQLFetchScroll** devuelve un error si el tamaño de conjunto de claves es mayor que 0 y menor que el tamaño del conjunto de filas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1.0)|Un valor SQLULEN que especifica la cantidad máxima de datos que devuelve el controlador de un carácter o una columna binaria. Si *ValuePtr* es menor que la longitud de los datos disponibles, **SQLFetch** o **SQLGetData** trunca los datos y devuelve SQL_SUCCESS. Si *ValuePtr* es 0 (valor predeterminado), el controlador intenta devolver todos los datos disponibles.<br /><br /> Si la longitud especificada es menor que la cantidad mínima de datos que puede devolver el origen de datos o mayor que la cantidad máxima de datos que puede devolver el origen de datos, los sustitutos de controlador que valor y devuelve 01S02 SQLSTATE (valor de opción cambiado).<br /><br /> El valor de este atributo puede establecerse en un cursor abierto; Sin embargo, la configuración podría no surten efecto inmediatamente, en cuyo caso el controlador devolverá 01S02 SQLSTATE (valor de opción cambiado) y restablece el atributo a su valor original.<br /><br /> Este atributo está diseñado para reducir el tráfico de red y debe ser compatibles únicamente cuando el origen de datos (en lugar del controlador) en un controlador de varios niveles puede implementarla. Este mecanismo no debe usarse con las aplicaciones para truncar datos; para truncar los datos recibidos, una aplicación debe especificar la longitud máxima del búfer en el *BufferLength* argumento en **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1.0)|Un valor SQLULEN correspondiente al número máximo de filas que se va a devolver a la aplicación para una **seleccione** instrucción. Si \* *ValuePtr* es igual a 0 (valor predeterminado), el controlador devuelve todas las filas.<br /><br /> Este atributo está pensado para reducir el tráfico de red. Conceptualmente, se aplica cuando el conjunto de resultados se crea y limita el conjunto de resultados a la primera *ValuePtr* filas. Si es mayor que el número de filas del conjunto de resultados *ValuePtr*, se trunca el conjunto de resultados.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos los conjuntos de resultados en el *instrucción*, los devueltos por las funciones de catálogo incluidos. SQL_ATTR_MAX_ROWS establece un máximo para el valor de recuento de filas de cursor.<br /><br /> Un controlador no debe emular el comportamiento SQL_ATTR_MAX_ROWS para **SQLFetch** o **SQLFetchScroll** (si las limitaciones de tamaño del conjunto de resultados no se puede implementar en el origen de datos) si no puede garantizar que SQL_ATTR_ MAX_ROWS se implementará correctamente.<br /><br /> Es definido por el controlador si SQL_ATTR_MAX_ROWS se aplica a las instrucciones que no sea de instrucciones SELECT (por ejemplo, las funciones de catálogo).<br /><br /> El valor de este atributo puede establecerse en un cursor abierto; Sin embargo, la configuración podría no surten efecto inmediatamente, en cuyo caso el controlador devolverá 01S02 SQLSTATE (valor de opción cambiado) y restablece el atributo a su valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3.0)|Un valor SQLULEN que determina cómo se tratan los argumentos de cadena de funciones de catálogo.<br /><br /> Si SQL_TRUE, el argumento de cadena de funciones de catálogo se tratan como identificadores. El caso no es significativo. Para cadenas sin delimitar, el controlador quita los espacios finales y se dobla la cadena a mayúsculas. Para cadenas delimitadas, el controlador quita los espacios iniciales o finales y toma cualquier es entre los delimitadores literalmente. Si se establece uno de estos argumentos a un puntero nulo, la función devuelve SQL_ERROR y SQLSTATE HY009 (uso no válido del puntero null).<br /><br /> Si SQL_FALSE, los argumentos de cadena de funciones de catálogo no se tratan como identificadores. El caso es significativo. O bien pueden contener un patrón de búsqueda de cadena o no, dependiendo del argumento.<br /><br /> El valor predeterminado es SQL_FALSE.<br /><br /> El *TableType* argumento de **SQLTables**, que toma una lista de valores, no se ve afectada por este atributo.<br /><br /> SQL_ATTR_METADATA_ID también puede establecerse en el nivel de conexión. (Se y SQL_ATTR_ASYNC_ENABLE son los atributos de instrucción única que también son atributos de conexión).<br /><br /> Para obtener más información, consulte [argumentos de las funciones de catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1.0)|Un valor SQLULEN que indica si el controlador debe analizar cadenas SQL para las secuencias de escape:<br /><br /> SQL_NOSCAN_OFF = los recorridos de controlador cadenas SQL para las secuencias de escape (valor predeterminado).<br /><br /> SQL_NOSCAN_ON = el controlador no examina las cadenas SQL para las secuencias de escape. En su lugar, el controlador envía la instrucción directamente al origen de datos.<br /><br /> Para obtener más información, consulte [secuencias de Escape de ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valor que señala a un desplazamiento que se agrega a punteros para cambiar el enlace de parámetros dinámicos. Si este campo es distinto de null, el controlador desreferencia el puntero, agrega el valor sin referencia a cada uno de los campos aplazados en el registro del descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y usa los nuevos valores de puntero al enlazar. Se establece en null de forma predeterminada.<br /><br /> El desplazamiento de enlace siempre se agrega directamente a los campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR. Si el desplazamiento se cambia a un valor diferente, el nuevo valor todavía se agrega directamente al valor en el campo descriptor. El desplazamiento nuevo no se agrega a los desplazamientos anteriores junto con el valor del campo.<br /><br /> Para obtener más información, consulte [enlace desplazamientos parámetro](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3.0)|Un valor SQLULEN que indica la orientación de enlace que se usará para los parámetros dinámicos.<br /><br /> Este campo se establece en SQL_PARAM_BIND_BY_COLUMN (valor predeterminado) para seleccionar el enlace.<br /><br /> Para seleccionar el enlace, este campo se establece en la longitud de la estructura o una instancia de un búfer que se enlazará a un conjunto de parámetros dinámicos. Esta longitud debe incluir el espacio para todos los parámetros enlazados y cualquier relleno de la estructura o el búfer para asegurarse de que cuando la dirección de un parámetro dependiente se incrementa con la longitud especificada, el resultado señalará al principio del mismo parámetro en el siguiente conjunto de parámetros. Cuando se usa el *sizeof* operador en ANSI C, se garantiza que este comportamiento.<br /><br /> Para obtener más información, consulte [enlazar las matrices de parámetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ BIND_TYPE en el encabezado APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valor que señala a una matriz de valores SQLUSMALLINT se usa para omitir un parámetro durante la ejecución de una instrucción SQL. Cada valor se establece en SQL_PARAM_PROCEED (para el parámetro que se ejecute) o SQL_PARAM_IGNORE (para el parámetro se pasa por alto).<br /><br /> Un conjunto de parámetros puede omitirse durante el procesamiento estableciendo el valor de estado de la matriz señalada por SQL_DESC_ARRAY_STATUS_PTR en el APD a SQL_PARAM_IGNORE. Si su valor de estado se establece en SQL_PARAM_PROCEED o si ningún elemento de la matriz se establece, se procesa un conjunto de parámetros.<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que el controlador de caso no parámetro devuelto valores de estado. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLExecDirect** o **SQLExecute** se llama.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* que contiene información de estado para cada fila de valores de parámetro después de llamar a los valores de valor que señala a una matriz de SQLUSMALLINT **SQLExecute** o **SQLExecDirect**. Este campo es obligatorio únicamente si PARAMSET_SIZE es mayor que 1.<br /><br /> Los valores de estado pueden contener los siguientes valores:<br /><br /> SQL_PARAM_SUCCESS: La instrucción SQL se ha ejecutado correctamente para este conjunto de parámetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: La instrucción SQL se ha ejecutado correctamente para este conjunto de parámetros; Sin embargo, la información sobre la advertencia está disponible en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_ERROR: Se produjo un error en el procesamiento de este conjunto de parámetros. Información de error adicional está disponible en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: Este conjunto de parámetros se sin usar, posiblemente debido al hecho de que algún conjunto anterior de parámetro ha producido un error que se ha anulado el procesamiento adicional, o porque se estableció SQL_PARAM_IGNORE para ese conjunto de parámetros en la matriz especificada por el SQL_ATTR_PARAM_ OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: El controlador trata a las matrices de parámetros como una unidad monolítica y así no genera este nivel de información de error.<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que el controlador de caso no parámetro devuelto valores de estado. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLExecute** o **SQLExecDirect** se llama. Observe que al establecer este atributo puede afectar el comportamiento del parámetro de salida implementado por el controlador.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3.0)|Un SQLULEN \* campos de registros que apunta a un búfer en el que se va a devolver el número de conjuntos de parámetros que se han procesado, incluidos los juegos de error. No se devolverá si se trata de un puntero nulo.<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IPD.<br /><br /> Si la llamada a **SQLExecDirect** o **SQLExecute** que rellena el búfer señalado por este atributo no se devuelve SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3.0)|Un valor SQLULEN que especifica el número de valores para cada parámetro. Si SQL_ATTR_PARAMSET_SIZE es mayor que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR del punto APD a las matrices. La cardinalidad de cada matriz es igual al valor de este campo.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, consulte [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_SIZE en el encabezado APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1.0)|Un valor SQLULEN correspondiente al número de segundos de espera para que una instrucción SQL para ejecutar antes de devolver a la aplicación. Si *ValuePtr* es igual a 0 (valor predeterminado), no hay ningún tiempo de espera.<br /><br /> Si el tiempo de espera especificado supera el tiempo de espera máximo en el origen de datos o es menor que el tiempo de espera mínimo **SQLSetStmtAttr** sustituye ese valor y devuelve 01S02 SQLSTATE (valor de opción cambiado).<br /><br /> Tenga en cuenta que la aplicación no necesita llamar a **SQLCloseCursor** para volver a usar la instrucción si un **seleccione** instrucción agotó el tiempo de espera.<br /><br /> El tiempo de espera de consulta establecido en este atributo de instrucción es válida en los modos sincrónicos y asincrónicos.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2.0)|Un valor SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** y, en ODBC 3*.x*, **SQLFetch** recuperar los datos después de que coloca el cursor a la ubicación especificada. Ésta es la opción predeterminada.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** y, en ODBC 3*.x*, **SQLFetch** no recuperan los datos después de que coloca el cursor.<br /><br /> Al establecer SQL_RETRIEVE_DATA en SQL_RD_OFF, una aplicación puede comprobar que existe o recuperar un marcador de la fila sin incurrir en la sobrecarga de recuperar las filas en una fila. Para obtener más información, consulte [desplazamiento y captura filas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> El valor de este atributo puede establecerse en un cursor abierto; Sin embargo, la configuración podría no surten efecto inmediatamente, en cuyo caso el controlador devolverá 01S02 SQLSTATE (valor de opción cambiado) y restablece el atributo a su valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3.0)|Un valor SQLULEN que especifica el número de filas devueltas por cada llamada a **SQLFetch** o **SQLFetchScroll**. También es el número de filas en una matriz de marcador utilizada en una operación de marcador de forma masiva en **SQLBulkOperations**. El valor predeterminado es 1.<br /><br /> Si el tamaño de conjunto de filas especificado supera el tamaño de conjunto de filas máximo admitido por el origen de datos, el controlador sustituye ese valor y devuelve 01S02 SQLSTATE (valor de opción cambiado).<br /><br /> Para obtener más información, consulte [tamaño de conjunto de filas](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_SIZE en el encabezado de descartar.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3.0)|Un SQLULEN * valor que señala a un desplazamiento que se agrega a punteros para cambiar el enlace de datos de columna. Si este campo es distinto de null, el controlador desreferencia el puntero, agrega el valor sin referencia a cada uno de los campos aplazados en el registro del descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y usa los nuevos valores de puntero al enlazar. Se establece en null de forma predeterminada.<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado de descartar.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1.0)|Un valor SQLULEN que establece la orientación de enlace que se utilizará cuando **SQLFetch** o **SQLFetchScroll** se llama en la instrucción asociada. El enlace se selecciona estableciendo el valor en SQL_BIND_BY_COLUMN. El enlace se selecciona estableciendo el valor para la longitud de una estructura o una instancia de un búfer en el que se enlazarán las columnas de resultados.<br /><br /> Si se especifica una longitud, debe incluir el espacio para todas las columnas enlazadas y cualquier relleno de la estructura o el búfer para asegurarse de que cuando la dirección de una columna enlazada se incrementa con la longitud especificada, el resultado señalará al principio de la misma columna en th fila siguiente e. Cuando se usa el **sizeof** operador con estructuras o uniones en ANSI C, se garantiza que este comportamiento.<br /><br /> El enlace es la orientación de enlace predeterminada para **SQLFetch** y **SQLFetchScroll**.<br /><br /> Para obtener más información, consulte [enlace columnas para su uso con cursores de bloque](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_BIND_TYPE en el encabezado de descartar.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2.0)|Establece un valor SQLULEN es el número de la fila actual en todo el resultado. Si no se puede determinar el número de la fila actual o no hay ninguna fila, el controlador devuelve 0.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no se establece mediante una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valor que señala a una matriz de valores SQLUSMALLINT se usa para omitir una fila durante una operación masiva mediante **SQLSetPos**. Cada valor se establece en SQL_ROW_PROCEED (para la fila que se va a incluir en la operación masiva) o SQL_ROW_IGNORE (para la fila que desea excluir de la operación masiva). (No se puede omitir filas mediante el uso de esta matriz durante las llamadas a **SQLBulkOperations**.)<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que caso el controlador no devuelve los valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLSetPos** se llama.<br /><br /> Para obtener más información, consulte [actualizar filas en el conjunto de filas con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) y [eliminar filas en el conjunto de filas con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR el descartar.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3.0)|Un SQLUSMALLINT \* valor que señala a una matriz de SQLUSMALLINT valores que contengan valores de estado de fila después de llamar a **SQLFetch** o **SQLFetchScroll**. La matriz tiene tantos elementos como filas en el conjunto de filas.<br /><br /> Este atributo de instrucción puede establecerse en un puntero nulo, en el que caso el controlador no devuelve los valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero no se utiliza el nuevo valor hasta la próxima vez **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**, o  **SQLSetPos** se llama.<br /><br /> Para obtener más información, consulte [estado y número de filas capturado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IRD.<br /><br /> Este atributo ha sido asignado por un ODBC 2*.x* controlador para la *rgbRowStatus* matriz en una llamada a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3.0)|Un SQLULEN \* valor que señala a un búfer en el que se va a devolver el número de filas recuperadas después de llamar a **SQLFetch** o **SQLFetchScroll**; el número de filas afectadas por una operación masiva realizadas mediante una llamada a **SQLSetPos** con una *operación* argumento de SQL_REFRESH; o el número de filas afectadas por una operación masiva realizada por **SQLBulkOperations**. Este número incluye las filas de error.<br /><br /> Para obtener más información, consulte [estado y número de filas capturado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Al establecer este atributo de instrucción establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IRD.<br /><br /> Si la llamada a **SQLFetch** o **SQLFetchScroll** que rellena el búfer señalado por este atributo no se devuelve SQL_SUCCESS o SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2.0)|Un valor SQLULEN que especifica si los controladores que simulan colocados instrucciones update y delete garantiza que dichas instrucciones afectan a solo una sola fila.<br /><br /> Para simular actualización posicionada e instrucciones delete, la mayoría de los controladores construir una búsqueda **actualizar** o **eliminar** instrucción que lo contiene un **donde** cláusula que especifica el valor de cada columna en la fila actual. A menos que estas columnas componen una clave única, una instrucción puede afectar a más de una fila.<br /><br /> Para garantizar que dichas instrucciones afectan a una sola fila, el controlador determina las columnas de una clave única y agrega estas columnas al conjunto de resultados. Si una aplicación garantiza que las columnas del conjunto de resultados constituyen una clave única, el controlador no tiene que hacerlo. Esto puede reducir el tiempo de ejecución.<br /><br /> SQL_SC_NON_UNIQUE = el controlador garantiza que simula actualización por posición o las instrucciones delete afectará a una sola fila; es responsabilidad de la aplicación para hacerlo. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** devuelve SQLSTATE 01001 (conflictos de operación de Cursor).<br /><br /> SQL_SC_TRY_UNIQUE = los intentos de controlador para garantizar que simulan actualización por posición o eliminar instrucciones afectan a una sola fila. El controlador siempre ejecuta estas instrucciones, aunque podrían afectar a más de una fila, como cuando no hay ninguna clave única. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**, o **SQLSetPos** devuelve SQLSTATE 01001 (conflictos de operación de Cursor).<br /><br /> SQL_SC_UNIQUE = las garantías de controlador que simulan actualización por posición o eliminar instrucciones afectan a una sola fila. Si el controlador no puede garantizar esto en una instrucción determinada, **SQLExecDirect** o **SQLPrepare** devuelve un error.<br /><br /> Si el origen de datos proporciona SQL nativo admite la actualización por posición y eliminar las instrucciones y el controlador no simula los cursores, se devuelve SQL_SUCCESS cuando se solicita SQL_SC_UNIQUE para SQL_SIMULATE_CURSOR. Si se solicita SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE, se devuelve SQL_SUCCESS_WITH_INFO. Si el origen de datos proporciona el nivel SQL_SC_TRY_UNIQUE de soporte técnico y el controlador no lo hace, se devuelve SQL_SUCCESS se devuelve SQL_SUCCESS_WITH_INFO y SQL_SC_TRY_UNIQUE para SQL_SC_NON_UNIQUE.<br /><br /> Si el tipo de simulación de cursor especificado no es compatible con el origen de datos, el controlador sustituye un tipo diferente de simulación y devuelve 01S02 SQLSTATE (valor de opción cambiado). En el caso de SQL_SC_UNIQUE, el controlador pasa, en orden, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Para SQL_SC_TRY_UNIQUE, el controlador sustituye SQL_SC_NON_UNIQUE.<br /><br /> El valor predeterminado es SQL_SC_UNIQUE.<br /><br /> Para obtener más información, consulte [simulando actualización coloca y eliminar instrucciones](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2.0)|Un valor SQLULEN que especifica si una aplicación va a utilizar marcadores con un cursor:<br /><br /> SQL_UB_OFF = Off (valor predeterminado)<br /><br /> SQL_UB_VARIABLE = una aplicación va a utilizar marcadores con un cursor, y el controlador proporcionará marcadores de longitud variable si se admiten. SQL_UB_FIXED está en desuso en ODBC 3*.x*. ODBC 3*.x* las aplicaciones siempre deben utilizar marcadores de longitud variable, incluso cuando se trabaja con ODBC 2*.x* controladores (que admiten marcadores solo de 4 bytes, de longitud fija). Esto es porque un marcador de longitud fija es simplemente un caso especial de un marcador de longitud variable. Cuando se trabaja con una API ODBC 2*.x* controlador, el Administrador de controladores asigna SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Para usar marcadores con un cursor, la aplicación debe especificar este atributo con el valor SQL_UB_VARIABLE antes de abrir el cursor.<br /><br /> Para obtener más información, consulte [recuperar marcadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] estas funciones se pueden llamar de forma asincrónica solo si el descriptor es un descriptor de implementación, no un descriptor de la aplicación.  
  
 Vea [el enlace de](../../../odbc/reference/develop-app/column-wise-binding.md) y [el enlace](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funciones relacionadas  
  
|Para obtener información acerca de|Vea|  
|---------------------------|---------|  
|Cancelar el procesamiento de una instrucción|[Función SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Devolver el valor de un atributo de conexión|[Función SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Devolver el valor de un atributo de instrucción|[Función SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Establecer un atributo de conexión|[Función SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Establecer un campo único del descriptor|[Función SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vea también  
 [Referencia de la API de ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Archivos de encabezado de ODBC](../../../odbc/reference/install/odbc-header-files.md)
