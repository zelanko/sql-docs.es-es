---
description: Función SQLSetStmtAttr
title: Función SQLSetStmtAttr | Microsoft Docs
ms.custom: ''
ms.date: 01/19/2017
ms.prod: sql
ms.prod_service: connectivity
ms.reviewer: ''
ms.technology: connectivity
ms.topic: conceptual
apiname:
- SQLSetStmtAttr
apilocation:
- sqlsrv32.dll
apitype: dllExport
f1_keywords:
- SQLSetStmtAttr
helpviewer_keywords:
- SQLSetStmtAttr function [ODBC]
ms.assetid: 7abc5260-733a-48d4-9974-2d1a6a9ea5f6
author: David-Engel
ms.author: v-daenge
ms.openlocfilehash: 7572a907a1111e1c6aa96a2761e8551d3265b2d6
ms.sourcegitcommit: e700497f962e4c2274df16d9e651059b42ff1a10
ms.translationtype: MT
ms.contentlocale: es-ES
ms.lasthandoff: 08/17/2020
ms.locfileid: "88421099"
---
# <a name="sqlsetstmtattr-function"></a>Función SQLSetStmtAttr
**Conformidad**  
 Versión introducida: compatibilidad con estándares de ODBC 3,0: ISO 92  
  
 **Resumen**  
 **SQLSetStmtAttr** establece atributos relacionados con una instrucción.  
  
> [!NOTE]
>  Para obtener más información sobre lo que el administrador de controladores asigna a esta función cuando una aplicación ODBC *3. x* está trabajando con un controlador ODBC *2. x* , consulte [asignación de funciones de reemplazo para mantener la compatibilidad con versiones anteriores de las aplicaciones](../../../odbc/reference/develop-app/mapping-replacement-functions-for-backward-compatibility-of-applications.md).  
  
## <a name="syntax"></a>Sintaxis  
  
```cpp  
  
SQLRETURN SQLSetStmtAttr(  
     SQLHSTMT      StatementHandle,  
     SQLINTEGER    Attribute,  
     SQLPOINTER    ValuePtr,  
     SQLINTEGER    StringLength);  
```  
  
## <a name="arguments"></a>Argumentos  
 *StatementHandle*  
 Entradas Identificador de instrucción.  
  
 *Atributo*  
 Entradas Opción que se va a establecer, que se muestra en "Comentarios".  
  
 *ValuePtr*  
 Entradas Valor que se va a asociar al *atributo*. Dependiendo del valor del *atributo*, *ValuePtr* será uno de los siguientes:  
  
-   Identificador de descriptor ODBC.  
  
-   Valor de SQLUINTEGER que incluya.  
  
-   Valor de SQLULEN.  
  
-   Un puntero a uno de los siguientes:  
  
    -   Cadena de caracteres terminada en NULL.  
  
    -   Búfer binario.  
  
    -   Un valor o una matriz de tipo SQLLEN, SQLULEN o SQLUSMALLINT.  
  
    -   Un valor definido por el controlador.  
  
 Si el argumento de *atributo* es un valor específico del controlador, *ValuePtr* puede ser un entero con signo.  
  
 *StringLength*  
 Entradas Si el *atributo* es un atributo definido por ODBC y *ValuePtr* apunta a una cadena de caracteres o a un búfer binario, este argumento debe ser la longitud de \* *ValuePtr*. Si el *atributo* es un atributo definido por ODBC y *ValuePtr* es un entero, *StringLength* se omite.  
  
 Si el *atributo* es un atributo definido por el controlador, la aplicación indica la naturaleza del atributo para el administrador de controladores mediante el establecimiento del argumento *StringLength* . *StringLength* puede tener los siguientes valores:  
  
-   Si *ValuePtr* es un puntero a una cadena de caracteres, *StringLength* es la longitud de la cadena o SQL_NTS.  
  
-   Si *ValuePtr* es un puntero a un búfer binario, la aplicación coloca el resultado de la macro SQL_LEN_BINARY_ATTR (*length*) en *StringLength*. Esto coloca un valor negativo en *StringLength*.  
  
-   Si *ValuePtr* es un puntero a un valor distinto de una cadena de caracteres o una cadena binaria, *StringLength* debe tener el valor SQL_IS_POINTER.  
  
-   Si *ValuePtr* contiene un valor de longitud fija, *StringLength* es SQL_IS_INTEGER o SQL_IS_UINTEGER, según corresponda.  
  
## <a name="returns"></a>Devoluciones  
 SQL_SUCCESS, SQL_SUCCESS_WITH_INFO, SQL_ERROR o SQL_INVALID_HANDLE.  
  
## <a name="diagnostics"></a>Diagnóstico  
 Cuando **SQLSetStmtAttr** devuelve SQL_ERROR o SQL_SUCCESS_WITH_INFO, se puede obtener un valor SQLSTATE asociado llamando a **SQLGetDiagRec** con un *HandleType* de SQL_HANDLE_STMT y un *identificador* de *StatementHandle*. En la tabla siguiente se enumeran los valores de SQLSTATE que devuelve normalmente **SQLSetStmtAttr** y se explica cada uno de ellos en el contexto de esta función. la notación "(DM)" precede a las descripciones de SQLSTATEs devueltas por el administrador de controladores. El código de retorno asociado a cada valor SQLSTATE es SQL_ERROR, a menos que se indique lo contrario.  
  
|SQLSTATE|Error|Descripción|  
|--------------|-----------|-----------------|  
|01000|ADVERTENCIA general|Mensaje informativo específico del controlador. (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|01S02|Valor de opción cambiado|El controlador no admitía el valor especificado en *ValuePtr*o el valor especificado en *ValuePtr* no era válido debido a las condiciones de trabajo de la implementación, por lo que el controlador sustituyó un valor similar. (Se puede llamar a**SQLGetStmtAttr** para determinar el valor sustituido temporalmente). El valor de sustitución es válido para *StatementHandle* hasta que se cierra el cursor, en cuyo punto el atributo de instrucción revierte a su valor anterior. Los atributos de instrucción que se pueden cambiar son:<br /><br /> SQL_ ATTR_CONCURRENCY SQL_ ATTR_CURSOR_TYPE SQL_ ATTR_KEYSET_SIZE SQL_ ATTR_MAX_LENGTH SQL_ ATTR_MAX_ROWS SQL_ ATTR_QUERY_TIMEOUT SQL_ATTR_ROW_ARRAY_SIZE SQL_ ATTR_SIMULATE_CURSOR<br /><br /> (La función devuelve SQL_SUCCESS_WITH_INFO).|  
|08S01|Error de vínculo de comunicación|Se produjo un error en el vínculo de comunicación entre el controlador y el origen de datos al que se conectó el controlador antes de que la función finalizara el procesamiento.|  
|24000|Estado de cursor no válido|El *atributo* estaba SQL_ATTR_CONCURRENCY, SQL_ATTR_CURSOR_TYPE, SQL_ATTR_SIMULATE_CURSOR o SQL_ATTR_USE_BOOKMARKS y el cursor estaba abierto.|  
|HY000|Error general|Se produjo un error para el que no había ningún SQLSTATE específico y para el que no se definió ningún SQLSTATE específico de la implementación. El mensaje de error devuelto por **SQLGetDiagRec** en el búfer * \* MessageText* describe el error y su causa.|  
|HY001|Error de asignación de memoria|El controlador no pudo asignar la memoria necesaria para admitir la ejecución o la finalización de la función.|  
|HY009|Uso no válido de puntero nulo|El argumento de *atributo* identificó un atributo de instrucción que requería un atributo de cadena y el argumento *ValuePtr* era un puntero nulo.|  
|HY010|Error de secuencia de función|(DM) se llamó a una función que se ejecuta de forma asincrónica para el identificador de conexión que está asociado a *StatementHandle*. Esta función asincrónica todavía se estaba ejecutando cuando se llamó a la función **SQLSetStmtAttr** .<br /><br /> Se llamó a **SQLExecute**, **SQLExecDirect**o **SQLMoreResults** para *StatementHandle* y se devolvió SQL_PARAM_DATA_AVAILABLE. Se llamó a esta función antes de recuperar los datos de todos los parámetros transmitidos por secuencias.<br /><br /> (DM) se llamó a una función que se ejecuta de forma asincrónica para *StatementHandle* y que todavía se estaba ejecutando cuando se llamó a esta función.<br /><br /> Se llamó a **SQLExecute**, **SQLExecDirect**, **SQLBulkOperations**o **SQLSetPos** para *StatementHandle* y se devolvió SQL_NEED_DATA. Se llamó a esta función antes de enviar los datos para todos los parámetros o columnas de datos en ejecución.|  
|HY011|El atributo no se puede establecer ahora|El *atributo* se SQL_ATTR_CONCURRENCY, SQL_ ATTR_CURSOR_TYPE, SQL_ ATTR_SIMULATE_CURSOR o SQL_ ATTR_USE_BOOKMARKS y la instrucción se preparó.|  
|HY013|Error de administración de memoria|No se pudo procesar la llamada de función porque no se pudo tener acceso a los objetos de memoria subyacentes, posiblemente debido a condiciones de memoria insuficientes.|  
|HY017|Uso no válido de un identificador de descriptor asignado automáticamente|(DM) el argumento de *atributo* se SQL_ATTR_IMP_ROW_DESC o SQL_ATTR_IMP_PARAM_DESC.<br /><br /> (DM) el argumento de *atributo* se SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC y el valor de *ValuePtr* era un identificador de descriptor asignado implícitamente que no es el identificador asignado originalmente para ARD o APD.|  
|HY024|Valor de atributo no válido|Dado el valor de *atributo* especificado, se especificó un valor no válido en *ValuePtr*. (El administrador de controladores devuelve este SQLSTATE solo para los atributos de conexión y de instrucción que aceptan un conjunto discreto de valores, como SQL_ATTR_ACCESS_MODE o SQL_ ATTR_ASYNC_ENABLE. Para todos los demás atributos de conexión y de instrucción, el controlador debe comprobar el valor especificado en *ValuePtr*).<br /><br /> El argumento de *atributo* era SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC y *ValuePtr* era un identificador de descriptor asignado explícitamente que no está en la misma conexión que el argumento *StatementHandle* .|  
|HY090|Longitud de búfer o cadena no válida|(DM) * \* ValuePtr* es una cadena de caracteres y el argumento *StringLength* era menor que 0 pero no se SQL_NTS.|  
|HY092|Identificador de opción/atributo no válido|(DM) el valor especificado para el *atributo* argument no era válido para la versión de ODBC admitida por el controlador.<br /><br /> (DM) el valor especificado para el *atributo* argument era un atributo de solo lectura.|  
|HY117|La conexión se suspendió debido a un estado de transacción desconocido. Solo se permiten las funciones de desconexión y de solo lectura.|(DM) para obtener más información sobre el estado suspendido, consulte [función SQLEndTran](../../../odbc/reference/syntax/sqlendtran-function.md).|  
|HYC00|Característica opcional no implementada|El valor especificado para el *atributo* argument era un atributo de instrucción ODBC válido para la versión de ODBC admitida por el controlador, pero no era compatible con el controlador.<br /><br /> Se SQL_ATTR_ASYNC_ENABLE el argumento de *atributo* y una llamada a **SQLGetInfo** con un *InfoType* de SQL_ASYNC_MODE devuelve SQL_AM_CONNECTION.<br /><br /> Se SQL_ATTR_ENABLE_AUTO_IPD el argumento de *atributo* y se SQL_FALSE el valor del atributo de conexión SQL_ATTR_AUTO_IPD.|  
|HYT01|Tiempo de espera de conexión agotado|Expiró el tiempo de espera de conexión antes de que el origen de datos respondiera a la solicitud. El período de tiempo de espera de la conexión se establece mediante **SQLSetConnectAttr**, SQL_ATTR_CONNECTION_TIMEOUT.|  
|IM001|El controlador no admite esta función|(DM) el controlador asociado a *StatementHandle* no admite la función.|  
|S1118|El controlador no admite la notificación asincrónica|Si se llama a **SQLSetStmtAttr** para establecer SQL_ATTR_ASYNC_STMT_EVENT; el controlador no admite la notificación asincrónica.|  
  
## <a name="comments"></a>Comentarios  
 Los atributos de instrucción de una instrucción permanecen en vigor hasta que se cambien por otra llamada a **SQLSetStmtAttr** o hasta que la instrucción se quite llamando a **SQLFreeHandle**. La llamada a **SQLFreeStmt** con la opción SQL_CLOSE, SQL_UNBIND o SQL_RESET_PARAMS no restablece los atributos de la instrucción.  
  
 Algunos atributos de instrucción admiten la sustitución de un valor similar si el origen de datos no admite el valor especificado en *ValuePtr*. En tales casos, el controlador devuelve SQL_SUCCESS_WITH_INFO y SQLSTATE 01S02 (valor de opción cambiado). Por ejemplo, si el *atributo* es SQL_ATTR_CONCURRENCY y *ValuePtr* es SQL_CONCUR_ROWVER, y si el origen de datos no lo admite, el controlador sustituye SQL_CONCUR_VALUES y devuelve SQL_SUCCESS_WITH_INFO. Para determinar el valor sustituido, una aplicación llama a **SQLGetStmtAttr**.  
  
 El formato de la información que se establece con *ValuePtr* depende del *atributo*especificado. **SQLSetStmtAttr** acepta información de atributos en uno de dos formatos diferentes: una cadena de caracteres o un valor entero. El formato de cada se indica en la descripción del atributo. Este formato se aplica a la información devuelta por cada atributo en **SQLGetStmtAttr**. Las cadenas de caracteres señaladas por el argumento *ValuePtr* de **SQLSetStmtAttr** tienen una longitud de *StringLength*.  
  
> [!NOTE]
>  La capacidad de establecer atributos de instrucción en el nivel de conexión llamando a **SQLSetConnectAttr** está en desuso en ODBC *3. x*. Las aplicaciones ODBC *3. x* nunca deben establecer atributos de instrucción en el nivel de conexión. Los atributos de la instrucción ODBC *3. x* no se pueden establecer en el nivel de conexión, a excepción de los atributos SQL_ATTR_METADATA_ID y SQL_ATTR_ASYNC_ENABLE, que son atributos de conexión y de instrucción, y se pueden establecer en el nivel de conexión o en el nivel de instrucción.  
> 
> [!NOTE]
>  Los controladores ODBC *3. x* solo necesitan admitir esta funcionalidad si deben funcionar con aplicaciones ODBC *2. x* que establecen las opciones de la instrucción ODBC *2. x* en el nivel de conexión. Para obtener más información, vea "configuración de las opciones de instrucciones en el nivel de conexión" en [asignación de SQLSetConnectOption](../../../odbc/reference/appendixes/sqlsetconnectoption-mapping.md) en el Apéndice G: instrucciones de controlador para la compatibilidad con versiones anteriores.  
  
## <a name="statement-attributes-that-set-descriptor-fields"></a>Atributos de instrucción que establecen los campos de descriptor  
 Muchos atributos de instrucción se corresponden con un campo de encabezado de un descriptor. Al establecer estos atributos, se obtiene el valor de los campos del descriptor. La configuración de campos mediante una llamada a **SQLSetStmtAttr** en lugar de a **SQLSetDescField** tiene la ventaja de que no es necesario obtener un identificador de descriptor para la llamada de función.  
  
> [!CAUTION]  
>  La llamada a **SQLSetStmtAttr** para una instrucción puede afectar a otras instrucciones. Esto sucede cuando el APD o el ARD asociado a la instrucción se asigna explícitamente y también está asociado a otras instrucciones. Dado que **SQLSetStmtAttr** modifica APD o ARD, las modificaciones se aplican a todas las instrucciones a las que está asociado este descriptor. Si este no es el comportamiento necesario, la aplicación debe desasociar Este descriptor de las demás instrucciones (llamando a **SQLSetStmtAttr** para establecer el SQL_ATTR_APP_ROW_DESC o SQL_ATTR_APP_PARAM_DESC campo en un identificador de descriptor diferente) antes de llamar a **SQLSetStmtAttr** de nuevo.  
  
 Cuando se establece un campo descriptor como resultado de establecer el atributo de instrucción correspondiente, el campo se establece solo para los descriptores aplicables que están asociados actualmente a la instrucción identificada por el argumento *StatementHandle* y el valor de atributo no afecta a los descriptores que puedan estar asociados a esa instrucción en el futuro. Cuando un campo de descriptor que también es un atributo de instrucción se establece mediante una llamada a **SQLSetDescField**, se establece el atributo de instrucción correspondiente. Si un descriptor asignado explícitamente se desasocia de una instrucción, un atributo de instrucción que se corresponda con un campo de encabezado revertirá al valor del campo en el descriptor asignado implícitamente.  
  
 Cuando se asigna una instrucción (vea [SQLAllocHandle](../../../odbc/reference/syntax/sqlallochandle-function.md)), se asignan cuatro identificadores de descriptor automáticamente y se asocian a la instrucción. Los identificadores de descriptor asignados explícitamente se pueden asociar a la instrucción llamando a **SQLAllocHandle** con un *fHandleType* de SQL_HANDLE_DESC para asignar un identificador de descriptor y, a continuación, llamar a **SQLSetStmtAttr** para asociar el identificador de descriptor a la instrucción.  
  
 Los atributos de instrucción de la siguiente tabla corresponden a los campos de encabezado del descriptor.  
  
|Atributo de instrucción|Campo de encabezado|Multilínea.|  
|-------------------------|------------------|-----------|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|APD|  
|SQL_ATTR_PARAM_BIND_TYPE|SQL_DESC_BIND_TYPE|APD|  
|SQL_ATTR_PARAM_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|APD|  
|SQL_ATTR_PARAM_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IPD|  
|SQL_ATTR_PARAMS_PROCESSED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IPD|  
|SQL_ATTR_PARAMSET_SIZE|SQL_DESC_ARRAY_SIZE|APD|  
|SQL_ATTR_ROW_ARRAY_SIZE|SQL_DESC_ARRAY_SIZE|ARD|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR|SQL_DESC_BIND_OFFSET_PTR|ARD|  
|SQL_ATTR_ROW_BIND_TYPE|SQL_DESC_BIND_TYPE|ARD|  
|SQL_ATTR_ROW_OPERATION_PTR|SQL_DESC_ARRAY_STATUS_PTR|ARD|  
|SQL_ATTR_ROW_STATUS_PTR|SQL_DESC_ARRAY_STATUS_PTR|IRD|  
|SQL_ATTR_ROWS_FETCHED_PTR|SQL_DESC_ROWS_PROCESSED_PTR|IRD|  
  
## <a name="statement-attributes"></a>Atributos de instrucción  
 En la tabla siguiente se muestran los atributos definidos actualmente y la versión de ODBC en la que se introdujeron. se espera que los controladores definan más atributos para aprovechar los distintos orígenes de datos. ODBC reserva un intervalo de atributos; los programadores de controladores deben reservar valores para su propio uso específico del controlador desde Open Group. Para obtener más información, vea [tipos de datos específicos del controlador, tipos de descriptores, tipos de información, tipos de diagnóstico y atributos](../../../odbc/reference/develop-app/driver-specific-data-types-descriptor-information-diagnostic.md).  
  
|Atributo|Contenido de *ValuePtr*|  
|---------------|-------------------------|  
|SQL_ATTR_APP_PARAM_DESC (ODBC 3,0)|Identificador de APD para las llamadas posteriores a **SQLExecute** y **SQLExecDirect** en el identificador de instrucción. El valor inicial de este atributo es el descriptor asignado implícitamente cuando se asignó inicialmente la instrucción. Si el valor de este atributo se establece en SQL_NULL_DESC o en el identificador originalmente asignado para el descriptor, se desasocia de él un identificador APD asignado explícitamente que se asoció previamente al identificador de instrucción y el identificador de instrucción se revierte al identificador APD asignado implícitamente.<br /><br /> Este atributo no se puede establecer en un identificador de descriptor que se asignó implícitamente para otra instrucción o en otro identificador de descriptor que se estableció implícitamente en la misma instrucción; los identificadores de descriptor asignados implícitamente no se pueden asociar a más de un identificador de instrucción o descriptor.|  
|SQL_ATTR_APP_ROW_DESC (ODBC 3,0)|Identificador de ARD para las capturas posteriores en el identificador de instrucción. El valor inicial de este atributo es el descriptor asignado implícitamente cuando se asignó inicialmente la instrucción. Si el valor de este atributo se establece en SQL_NULL_DESC o en el identificador originalmente asignado para el descriptor, se desasocia de él un identificador ARD asignado explícitamente que se asoció previamente al identificador de instrucción y el identificador de instrucción se revierte al identificador ARD asignado implícitamente.<br /><br /> Este atributo no se puede establecer en un identificador de descriptor que se asignó implícitamente para otra instrucción o en otro identificador de descriptor que se estableció implícitamente en la misma instrucción; los identificadores de descriptor asignados implícitamente no se pueden asociar a más de un identificador de instrucción o descriptor.|  
|SQL_ATTR_ASYNC_ENABLE (ODBC 1,0)|Un valor SQLULEN que especifica si una función llamada con la instrucción especificada se ejecuta de forma asincrónica:<br /><br /> SQL_ASYNC_ENABLE_OFF = deshabilitar la compatibilidad con la ejecución asincrónica de nivel de instrucción (valor predeterminado).<br /><br /> SQL_ASYNC_ENABLE_ON = habilitar la compatibilidad con la ejecución asincrónica de nivel de instrucción.<br /><br /> Para obtener más información, vea [ejecución asincrónica (método de sondeo)](../../../odbc/reference/develop-app/asynchronous-execution-polling-method.md).<br /><br /> En el caso de los controladores con compatibilidad de ejecución asincrónica de nivel de instrucción, el atributo de instrucción SQL_ATTR_ASYNC_ENABLE es de solo lectura. Su valor es el mismo que el valor del atributo de nivel de conexión con el mismo nombre en el momento en que se asignó el identificador de instrucción.<br /><br /> Llamar a **SQLSetStmtAttr** para establecer SQL_ATTR_ASYNC_ENABLE cuando el SQL_ASYNC_MODE *InfoType* devuelve SQL_AM_CONNECTION devuelve SQLSTATE HYC00 (característica opcional no implementada). Para obtener más información, consulte [SQLSetConnectAttr (función](../../../odbc/reference/syntax/sqlsetconnectattr-function.md) ) para obtener más información.|  
|SQL_ATTR_ASYNC_STMT_EVENT (ODBC 3,8)|Un valor de SQLPOINTER que es un identificador de evento.<br /><br /> La notificación de la finalización de las funciones asincrónicas se habilita llamando a **SQLSetStmtAttr** para establecer el atributo de **SQL_ATTR_ASYNC_STMT_EVENT** y especificar el identificador de evento.|  
|SQL_ATTR_ASYNC_STMT_PCALLBACK (ODBC 3,8)|SQLPOINTER a la función de devolución de llamada asincrónica.<br /><br /> Solo el administrador de controladores puede llamar a la función **SQLSetStmtAttr** de un controlador con este atributo.|  
|SQL_ATTR_ASYNC_STMT_PCONTEXT (ODBC 3,8)|SQLPOINTER a la estructura de contexto.<br /><br /> Solo el administrador de controladores puede llamar a la función **SQLSetStmtAttr** de un controlador con este atributo.|  
|SQL_ATTR_CONCURRENCY (ODBC 2,0)|Valor SQLULEN que especifica la simultaneidad del cursor:<br /><br /> SQL_CONCUR_READ_ONLY = el cursor es de solo lectura. No se permiten actualizaciones.<br /><br /> SQL_CONCUR_LOCK = cursor utiliza el nivel más bajo de bloqueo suficiente para asegurarse de que se puede actualizar la fila.<br /><br /> SQL_CONCUR_ROWVER = cursor utiliza el control de simultaneidad optimista, comparando las versiones de fila como SQLBase ROWID o Sybase TIMESTAMP.<br /><br /> SQL_CONCUR_VALUES = cursor utiliza el control de simultaneidad optimista, comparando valores.<br /><br /> El valor predeterminado para SQL_ATTR_CONCURRENCY es SQL_CONCUR_READ_ONLY.<br /><br /> No se puede especificar este atributo para un cursor abierto. Para obtener más información, vea [tipos de simultaneidad](../../../odbc/reference/develop-app/concurrency-types.md).<br /><br /> Si el *atributo* SQL_ATTR_CURSOR_TYPE se cambia a un tipo que no admite el valor actual de SQL_ATTR_CONCURRENCY, el valor de SQL_ATTR_CONCURRENCY cambiará en tiempo de ejecución y se emitirá una advertencia cuando se llame a **SQLExecDirect** o a **SQLPrepare** .<br /><br /> Si el controlador admite la instrucción **Select for update** y esta instrucción se ejecuta mientras el valor de SQL_ATTR_CONCURRENCY está establecido en SQL_CONCUR_READ_ONLY, se devolverá un error. Si el valor de SQL_ATTR_CONCURRENCY se cambia a un valor que el controlador admite para algún valor de SQL_ATTR_CURSOR_TYPE pero no para el valor actual de SQL_ATTR_CURSOR_TYPE, el valor de SQL_ATTR_CURSOR_TYPE se cambiará en tiempo de ejecución y se emitirá 01S02 SQLSTATE (valor de opción cambiado) cuando se llame a **SQLExecDirect** o a **SQLPrepare** .<br /><br /> Si el origen de datos no admite la simultaneidad especificada, el controlador sustituye a una simultaneidad distinta y devuelve SQLSTATE 01S02 (valor de opción cambiado). Por SQL_CONCUR_VALUES, el controlador sustituye SQL_CONCUR_ROWVER y viceversa. Por SQL_CONCUR_LOCK, el controlador sustituye, en orden, SQL_CONCUR_ROWVER o SQL_CONCUR_VALUES. La validez del valor sustituido no se comprueba hasta el tiempo de ejecución.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CONCURRENCY y los demás atributos de cursor, vea [características del cursor y tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_SCROLLABLE (ODBC 3,0)|Valor SQLULEN que especifica el nivel de compatibilidad que requiere la aplicación. Establecer este atributo afecta a las llamadas posteriores a **SQLExecDirect** y **SQLExecute**.<br /><br /> SQL_NONSCROLLABLE = los cursores desplazables no son necesarios en el identificador de instrucción. Si la aplicación llama a **SQLFetchScroll** en este controlador, el único valor válido de *FetchOrientation* es SQL_FETCH_NEXT. Este es el valor predeterminado.<br /><br /> SQL_SCROLLABLE = los cursores desplazables son necesarios en el identificador de instrucción. Al llamar a **SQLFetchScroll**, la aplicación puede especificar cualquier valor válido de *FetchOrientation*, con lo que se logra el posicionamiento del cursor en modos distintos del modo secuencial.<br /><br /> Para obtener más información sobre los cursores desplazables, vea [cursores desplazables](../../../odbc/reference/develop-app/scrollable-cursors.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SCROLLABLE y los demás atributos de cursor, vea [características de cursor y tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md) .|  
|SQL_ATTR_CURSOR_SENSITIVITY (ODBC 3,0)|Un valor SQLULEN que especifica si los cursores del identificador de instrucción hacen visibles los cambios realizados en un conjunto de resultados por otro cursor. Establecer este atributo afecta a las llamadas posteriores a **SQLExecDirect** y **SQLExecute**. Una aplicación puede volver a leer el valor de este atributo para obtener su estado inicial o su estado, tal y como lo ha establecido la aplicación más recientemente.<br /><br /> SQL_UNSPECIFIED = no se especifica cuál es el tipo de cursor y si los cursores del controlador de la instrucción hacen visibles los cambios realizados en un conjunto de resultados por otro cursor. Los cursores del identificador de instrucción pueden hacer visibles ninguno, algunos o todos esos cambios. Este es el valor predeterminado.<br /><br /> SQL_INSENSITIVE = todos los cursores del identificador de instrucción muestran el conjunto de resultados sin reflejar ningún cambio realizado en él por ningún otro cursor. Los cursores insensitive son de solo lectura. Esto corresponde a un cursor estático, que tiene una simultaneidad que es de solo lectura.<br /><br /> SQL_SENSITIVE = todos los cursores del identificador de instrucción hacen visibles todos los cambios realizados en un conjunto de resultados por otro cursor.<br /><br /> Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_SENSITIVITY y los demás atributos de cursor, vea [características del cursor y tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_CURSOR_TYPE (ODBC 2,0)|Un valor SQLULEN que especifica el tipo de cursor:<br /><br /> SQL_CURSOR_FORWARD_ONLY = el cursor solo se desplaza hacia delante.<br /><br /> SQL_CURSOR_STATIC = los datos del conjunto de resultados son estáticos.<br /><br /> SQL_CURSOR_KEYSET_DRIVEN = el controlador guarda y usa las claves para el número de filas especificado en el atributo de la instrucción SQL_ATTR_KEYSET_SIZE.<br /><br /> SQL_CURSOR_DYNAMIC = el controlador guarda y usa solo las claves para las filas del conjunto de filas.<br /><br /> El valor predeterminado es SQL_CURSOR_FORWARD_ONLY. No se puede especificar este atributo una vez preparada la instrucción SQL.<br /><br /> Si el origen de datos no admite el tipo de cursor especificado, el controlador sustituye a un tipo de cursor diferente y devuelve SQLSTATE 01S02 (valor de opción cambiado). Para un cursor mixto o dinámico, el controlador sustituye, en orden, un cursor controlado por conjunto de claves o un cursor estático. Para un cursor controlado por conjunto de claves, el controlador sustituye a un cursor estático.<br /><br /> Para obtener más información sobre los tipos de cursor desplazables, vea [tipos de cursor desplazables](../../../odbc/reference/develop-app/scrollable-cursor-types.md). Para obtener más información sobre la relación entre SQL_ATTR_CURSOR_TYPE y los demás atributos de cursor, vea [características del cursor y tipo de cursor](../../../odbc/reference/develop-app/cursor-characteristics-and-cursor-type.md).|  
|SQL_ATTR_ENABLE_AUTO_IPD (ODBC 3,0)|Un valor SQLULEN que especifica si se realiza el rellenado automático de IPD:<br /><br /> SQL_TRUE = activa el rellenado automático de IPD después de una llamada a **SQLPrepare**. SQL_FALSE = desactiva el rellenado automático de IPD después de una llamada a **SQLPrepare**. (Una aplicación todavía puede obtener información del campo IPD llamando a **SQLDescribeParam**, si se admite). El valor predeterminado del atributo de instrucción SQL_ATTR_ENABLE_AUTO_IPD es SQL_FALSE. Para obtener más información, vea [rellenado automático de IPD](../../../odbc/reference/develop-app/automatic-population-of-the-ipd.md).|  
|SQL_ATTR_FETCH_BOOKMARK_PTR (ODBC 3,0)|SQLLEN \* que apunta a un valor de marcador binario. Cuando se llama a **SQLFetchScroll** con *fFetchOrientation* igual a SQL_FETCH_BOOKMARK, el controlador recoge el valor de marcador de este campo. El valor predeterminado de este campo es un puntero nulo. Para obtener más información, vea [desplazarse por marcador](../../../odbc/reference/develop-app/scrolling-by-bookmark.md).<br /><br /> El valor al que apunta este campo no se usa para las operaciones de eliminación por marcador, actualización por marcador o captura por marcador en **SQLBulkOperations**, que usan marcadores almacenados en caché en búferes de conjuntos de filas.|  
|SQL_ATTR_IMP_PARAM_DESC (ODBC 3,0)|Identificador de la. El valor de este atributo es el descriptor asignado cuando se asignó inicialmente la instrucción. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no establecida por una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_IMP_ROW_DESC (ODBC 3,0)|Identificador de IRD. El valor de este atributo es el descriptor asignado cuando se asignó inicialmente la instrucción. La aplicación no puede establecer este atributo.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no establecida por una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_KEYSET_SIZE (ODBC 2,0)|SQLULEN que especifica el número de filas del conjunto de claves para un cursor controlado por conjunto de claves. Si el tamaño del conjunto de claves es 0 (el valor predeterminado), el cursor está completamente controlado por conjunto de claves. Si el tamaño del conjunto de claves es mayor que 0, el cursor es mixto (controlado por conjunto de claves dentro del conjunto de claves y dinámico fuera del conjunto de claves). El tamaño predeterminado del conjunto de claves es 0. Para obtener más información acerca de los cursores controlados por conjunto de claves, consulte [cursores](../../../odbc/reference/develop-app/keyset-driven-cursors.md)controlados por conjunto de claves.<br /><br /> Si el tamaño especificado supera el tamaño máximo del conjunto de claves, el controlador sustituye ese tamaño y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> **SQLFetch** o **SQLFetchScroll** devuelve un error si el tamaño del conjunto de claves es mayor que 0 y menor que el tamaño del conjunto de filas.|  
|SQL_ATTR_MAX_LENGTH (ODBC 1,0)|Un valor SQLULEN que especifica la cantidad máxima de datos que el controlador devuelve de una columna de caracteres o binaria. Si *ValuePtr* es menor que la longitud de los datos disponibles, **SQLFetch** o **SQLGetData** trunca los datos y devuelve SQL_SUCCESS. Si *ValuePtr* es 0 (el valor predeterminado), el controlador intenta devolver todos los datos disponibles.<br /><br /> Si la longitud especificada es menor que la cantidad mínima de datos que el origen de datos puede devolver o mayor que la cantidad máxima de datos que el origen de datos puede devolver, el controlador sustituye ese valor y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> El valor de este atributo se puede establecer en un cursor abierto; sin embargo, es posible que la configuración no surta efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 (valor de opción cambiado) y restablecerá el atributo a su valor original.<br /><br /> Este atributo está pensado para reducir el tráfico de red y solo debe admitirse cuando el origen de datos (en oposición al controlador) de un controlador de varios niveles puede implementarlo. Las aplicaciones no deben usar este mecanismo para truncar los datos; para truncar los datos recibidos, una aplicación debe especificar la longitud máxima del búfer en el argumento *BufferLength* de **SQLBindCol** o **SQLGetData**.|  
|SQL_ATTR_MAX_ROWS (ODBC 1,0)|Un valor SQLULEN que corresponde al número máximo de filas que se va a devolver a la aplicación para una instrucción **Select** . Si \* *ValuePtr* es igual a 0 (el valor predeterminado), el controlador devuelve todas las filas.<br /><br /> Este atributo está pensado para reducir el tráfico de red. Conceptualmente, se aplica cuando se crea el conjunto de resultados y limita el conjunto de resultados a las primeras filas de *ValuePtr* . Si el número de filas del conjunto de resultados es mayor que *ValuePtr*, el conjunto de resultados se trunca.<br /><br /> SQL_ATTR_MAX_ROWS se aplica a todos los conjuntos de resultados de la *instrucción*, incluidos los devueltos por las funciones de catálogo. SQL_ATTR_MAX_ROWS establece un máximo para el valor del recuento de filas del cursor.<br /><br /> Un controlador no debe emular SQL_ATTR_MAX_ROWS comportamiento para **SQLFetch** o **SQLFetchScroll** (si no se pueden implementar limitaciones de tamaño del conjunto de resultados en el origen de datos) si no puede garantizar que SQL_ATTR_MAX_ROWS se implementará correctamente.<br /><br /> Está definido por el controlador si SQL_ATTR_MAX_ROWS se aplica a instrucciones distintas de las instrucciones SELECT (como las funciones de catálogo).<br /><br /> El valor de este atributo se puede establecer en un cursor abierto; sin embargo, es posible que la configuración no surta efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 (valor de opción cambiado) y restablecerá el atributo a su valor original.|  
|SQL_ATTR_METADATA_ID (ODBC 3,0)|Un valor SQLULEN que determina cómo se tratan los argumentos de cadena de las funciones de catálogo.<br /><br /> Si SQL_TRUE, el argumento de cadena de las funciones de catálogo se tratan como identificadores. El caso no es significativo. En el caso de las cadenas no delimitadas, el controlador quita los espacios finales y la cadena se dobla a mayúsculas. En el caso de las cadenas delimitadas, el controlador quita los espacios iniciales o finales y toma el número de delimitadores literalmente. Si uno de estos argumentos se establece en un puntero nulo, la función devuelve SQL_ERROR y SQLSTATE HY009 (uso no válido de puntero nulo).<br /><br /> Si SQL_FALSE, los argumentos de cadena de las funciones de catálogo no se tratan como identificadores. El caso es significativo. Pueden contener un modelo de búsqueda de cadenas o no, dependiendo del argumento.<br /><br /> El valor predeterminado es SQL_FALSE.<br /><br /> El argumento *TableType* de **SQLTables**, que toma una lista de valores, no se ve afectado por este atributo.<br /><br /> También se puede establecer SQL_ATTR_METADATA_ID en el nivel de conexión. (Y SQL_ATTR_ASYNC_ENABLE son los únicos atributos de instrucción que también son atributos de conexión).<br /><br /> Para obtener más información, vea [argumentos en funciones de catálogo](../../../odbc/reference/develop-app/arguments-in-catalog-functions.md).|  
|SQL_ATTR_NOSCAN (ODBC 1,0)|Un valor SQLULEN que indica si el controlador debe examinar las cadenas SQL para las secuencias de escape:<br /><br /> SQL_NOSCAN_OFF = el controlador examina las cadenas SQL para las secuencias de escape (el valor predeterminado).<br /><br /> SQL_NOSCAN_ON = el controlador no examina las cadenas SQL para las secuencias de escape. En su lugar, el controlador envía la instrucción directamente al origen de datos.<br /><br /> Para obtener más información, vea [secuencias de escape en ODBC](../../../odbc/reference/develop-app/escape-sequences-in-odbc.md).|  
|SQL_ATTR_PARAM_BIND_OFFSET_PTR (ODBC 3,0)|Un valor de SQLULEN * que apunta a un desplazamiento agregado a los punteros para cambiar el enlace de los parámetros dinámicos. Si este campo no es null, el controlador desreferencia el puntero, agrega el valor desreferenciado a cada uno de los campos diferidos del registro del descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y utiliza los nuevos valores de puntero al enlazar. De forma predeterminada, se establece en NULL.<br /><br /> El desplazamiento de enlace siempre se agrega directamente a los campos SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR. Si el desplazamiento se cambia a un valor diferente, el nuevo valor todavía se agrega directamente al valor en el campo descriptor. El nuevo desplazamiento no se agrega al valor del campo más los desplazamientos anteriores.<br /><br /> Para obtener más información, vea [desplazamientos de enlaces de parámetros](../../../odbc/reference/develop-app/parameter-binding-offsets.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_BIND_TYPE (ODBC 3,0)|Valor de SQLULEN que indica la orientación de enlace que se va a usar para los parámetros dinámicos.<br /><br /> Este campo se establece en SQL_PARAM_BIND_BY_COLUMN (valor predeterminado) para seleccionar el enlace de modo de columna.<br /><br /> Para seleccionar el enlace de modo de fila, este campo se establece en la longitud de la estructura o en una instancia de un búfer que se enlazará a un conjunto de parámetros dinámicos. Esta longitud debe incluir espacio para todos los parámetros enlazados y cualquier relleno de la estructura o búfer para asegurarse de que cuando la dirección de un parámetro enlazado se incrementa con la longitud especificada, el resultado apuntará al principio del mismo parámetro en el siguiente conjunto de parámetros. Al usar el operador *sizeof* en ANSI C, se garantiza este comportamiento.<br /><br /> Para obtener más información, vea [enlazar matrices de parámetros](../../../odbc/reference/develop-app/binding-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ BIND_TYPE del encabezado APD.|  
|SQL_ATTR_PARAM_OPERATION_PTR (ODBC 3,0)|Un \* valor SQLUSMALLINT que apunta a una matriz de valores SQLUSMALLINT utilizados para omitir un parámetro durante la ejecución de una instrucción SQL. Cada valor se establece en SQL_PARAM_PROCEED (para el parámetro que se va a ejecutar) o SQL_PARAM_IGNORE (para que se omita el parámetro).<br /><br /> Un conjunto de parámetros se puede omitir durante el procesamiento estableciendo el valor de estado en la matriz a la que apunta SQL_DESC_ARRAY_STATUS_PTR en APD para SQL_PARAM_IGNORE. Se procesa un conjunto de parámetros si su valor de estado se establece en SQL_PARAM_PROCEED o si no se establece ningún elemento de la matriz.<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de parámetro. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez que se llame a **SQLExecDirect** o **SQLExecute** .<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, vea [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado APD.|  
|SQL_ATTR_PARAM_STATUS_PTR (ODBC 3,0)|Un \* valor SQLUSMALLINT que apunta a una matriz de valores SQLUSMALLINT que contiene información de estado para cada fila de valores de parámetro después de una llamada a **SQLExecute** o **SQLExecDirect**. Este campo solo es necesario si PARAMSET_SIZE es mayor que 1.<br /><br /> Los valores de estado pueden contener los valores siguientes:<br /><br /> SQL_PARAM_SUCCESS: la instrucción SQL se ejecutó correctamente para este conjunto de parámetros.<br /><br /> SQL_PARAM_SUCCESS_WITH_INFO: la instrucción SQL se ejecutó correctamente para este conjunto de parámetros; sin embargo, la información de advertencia está disponible en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_ERROR: se produjo un error al procesar este conjunto de parámetros. Hay información adicional sobre el error en la estructura de datos de diagnóstico.<br /><br /> SQL_PARAM_UNUSED: este conjunto de parámetros no se usó, posiblemente debido al hecho de que algún conjunto de parámetros anterior produjo un error que ha anulado el procesamiento o porque se ha establecido SQL_PARAM_IGNORE para ese conjunto de parámetros en la matriz especificada por el SQL_ATTR_PARAM_OPERATION_PTR.<br /><br /> SQL_PARAM_DIAG_UNAVAILABLE: el controlador trata las matrices de parámetros como una unidad monolítica y, por tanto, no genera este nivel de información de error.<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de parámetro. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez que se llame a **SQLExecute** o **SQLExecDirect** . Tenga en cuenta que establecer este atributo puede afectar al comportamiento del parámetro de salida implementado por el controlador.<br /><br /> Para obtener más información, vea [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IPD.|  
|SQL_ATTR_PARAMS_PROCESSED_PTR (ODBC 3,0)|Un \* campo de registro SQLULEN que apunta a un búfer en el que se va a devolver el número de conjuntos de parámetros que se han procesado, incluidos los conjuntos de errores. No se devolverá ningún número si se trata de un puntero nulo.<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IPD.<br /><br /> Si la llamada a **SQLExecDirect** o **SQLExecute** que rellena el búfer señalado por este atributo no devuelve SQL_SUCCESS ni SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.<br /><br /> Para obtener más información, vea [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).|  
|SQL_ATTR_PARAMSET_SIZE (ODBC 3,0)|Valor SQLULEN que especifica el número de valores de cada parámetro. Si SQL_ATTR_PARAMSET_SIZE es mayor que 1, SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR del punto APD a las matrices. La cardinalidad de cada matriz es igual al valor de este campo.<br /><br /> Este atributo se omite cuando no hay ningún parámetro enlazado.<br /><br /> Para obtener más información, vea [usar matrices de parámetros](../../../odbc/reference/develop-app/using-arrays-of-parameters.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ARRAY_SIZE en el encabezado APD.|  
|SQL_ATTR_QUERY_TIMEOUT (ODBC 1,0)|Un valor SQLULEN que corresponde al número de segundos que se debe esperar para que una instrucción SQL se ejecute antes de volver a la aplicación. Si *ValuePtr* es igual a 0 (valor predeterminado), no hay tiempo de espera.<br /><br /> Si el tiempo de espera especificado supera el tiempo de espera máximo del origen de datos o es menor que el tiempo de espera mínimo, **SQLSetStmtAttr** sustituye ese valor y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> Tenga en cuenta que la aplicación no necesita llamar a **SQLCloseCursor** para volver a usar la instrucción si se ha agotado el tiempo de espera de una instrucción **Select** .<br /><br /> El tiempo de espera de consulta establecido en este atributo de instrucción es válido en los modos sincrónico y asincrónico.|  
|SQL_ATTR_RETRIEVE_DATA (ODBC 2,0)|Un valor de SQLULEN:<br /><br /> SQL_RD_ON = **SQLFetchScroll** y, en ODBC *3. x*, el **SQLFetch** recupera datos después de colocar el cursor en la ubicación especificada. Este es el valor predeterminado.<br /><br /> SQL_RD_OFF = **SQLFetchScroll** y, en ODBC *3. x*, **SQLFetch** no recupera los datos después de colocar el cursor.<br /><br /> Al establecer SQL_RETRIEVE_DATA en SQL_RD_OFF, una aplicación puede comprobar que existe una fila o recuperar un marcador de la fila sin incurrir en la sobrecarga que supone recuperar filas. Para obtener más información, vea [desplazamiento y captura de filas](../../../odbc/reference/develop-app/scrolling-and-fetching-rows-odbc.md).<br /><br /> El valor de este atributo se puede establecer en un cursor abierto; sin embargo, es posible que la configuración no surta efecto inmediatamente, en cuyo caso el controlador devolverá SQLSTATE 01S02 (valor de opción cambiado) y restablecerá el atributo a su valor original.|  
|SQL_ATTR_ROW_ARRAY_SIZE (ODBC 3,0)|Un valor SQLULEN que especifica el número de filas devueltas por cada llamada a **SQLFetch** o **SQLFetchScroll**. También es el número de filas de una matriz de marcadores utilizada en una operación de marcador masivo en **SQLBulkOperations**. El valor predeterminado es 1.<br /><br /> Si el tamaño del conjunto de filas especificado supera el tamaño máximo permitido para el origen de datos, el controlador sustituye ese valor y devuelve SQLSTATE 01S02 (valor de opción cambiado).<br /><br /> Para obtener más información, vea [tamaño del conjunto de filas](../../../odbc/reference/develop-app/rowset-size.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ARRAY_SIZE en el encabezado ARD.|  
|SQL_ATTR_ROW_BIND_OFFSET_PTR (ODBC 3,0)|Un valor de SQLULEN * que apunta a un desplazamiento agregado a punteros para cambiar el enlace de datos de columna. Si este campo no es null, el controlador desreferencia el puntero, agrega el valor desreferenciado a cada uno de los campos diferidos del registro del descriptor (SQL_DESC_DATA_PTR, SQL_DESC_INDICATOR_PTR y SQL_DESC_OCTET_LENGTH_PTR) y utiliza los nuevos valores de puntero al enlazar. De forma predeterminada, se establece en NULL.<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_BIND_OFFSET_PTR en el encabezado ARD.|  
|SQL_ATTR_ROW_BIND_TYPE (ODBC 1,0)|Valor de SQLULEN que establece la orientación de enlace que se va a usar cuando se llama a **SQLFetch** o **SQLFetchScroll** en la instrucción asociada. El enlace de modo de columna se selecciona estableciendo el valor en SQL_BIND_BY_COLUMN. El enlace de modo de fila se selecciona estableciendo el valor en la longitud de una estructura o en una instancia de un búfer en el que se enlazarán las columnas de resultados.<br /><br /> Si se especifica una longitud, debe incluir espacio para todas las columnas enlazadas y cualquier relleno de la estructura o búfer para asegurarse de que cuando la dirección de una columna enlazada se incrementa con la longitud especificada, el resultado apunta al principio de la misma columna en la fila siguiente. Al usar el operador **sizeof** con estructuras o uniones en ANSI C, se garantiza este comportamiento.<br /><br /> El enlace de modo de columna es la orientación de enlace predeterminada para **SQLFetch** y **SQLFetchScroll**.<br /><br /> Para obtener más información, vea [enlazar columnas para su uso con cursores de bloque](../../../odbc/reference/develop-app/binding-columns-for-use-with-block-cursors.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_BIND_TYPE en el encabezado ARD.|  
|SQL_ATTR_ROW_NUMBER (ODBC 2,0)|Un valor SQLULEN que es el número de la fila actual en todo el conjunto de resultados. Si no se puede determinar el número de la fila actual o no hay ninguna fila actual, el controlador devuelve 0.<br /><br /> Este atributo se puede recuperar mediante una llamada a **SQLGetStmtAttr** pero no establecida por una llamada a **SQLSetStmtAttr**.|  
|SQL_ATTR_ROW_OPERATION_PTR (ODBC 3,0)|Un \* valor SQLUSMALLINT que apunta a una matriz de valores SQLUSMALLINT usados para omitir una fila durante una operación masiva mediante **SQLSetPos**. Cada valor se establece en SQL_ROW_PROCEED (para que la fila se incluya en la operación masiva) o SQL_ROW_IGNORE (para que la fila se excluya de la operación masiva). (Las filas no se pueden omitir con esta matriz durante las llamadas a **SQLBulkOperations**).<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez que se llame a **SQLSetPos** .<br /><br /> Para obtener más información, vea [Actualizar filas en el conjunto de filas con SQLSetPos](../../../odbc/reference/develop-app/updating-rows-in-the-rowset-with-sqlsetpos.md) y [eliminar filas en el conjunto de filas con SQLSetPos](../../../odbc/reference/develop-app/deleting-rows-in-the-rowset-with-sqlsetpos.md).<br /><br /> Al establecer este atributo de instrucción, se establece el SQL_DESC_ARRAY_STATUS_PTR campo en ARD.|  
|SQL_ATTR_ROW_STATUS_PTR (ODBC 3,0)|Un \* valor de SQLUSMALLINT que apunta a una matriz de valores de SQLUSMALLINT que contienen valores de estado de fila después de una llamada a **SQLFetch** o **SQLFetchScroll**. La matriz tiene tantos elementos como filas hay en el conjunto de filas.<br /><br /> Este atributo de instrucción se puede establecer en un puntero nulo, en cuyo caso el controlador no devuelve valores de estado de fila. Este atributo se puede establecer en cualquier momento, pero el nuevo valor no se utiliza hasta la próxima vez que se llama a **SQLBulkOperations**, **SQLFetch**, **SQLFetchScroll**o **SQLSetPos** .<br /><br /> Para obtener más información, vea [número de filas recuperadas y estado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ARRAY_STATUS_PTR en el encabezado IRD.<br /><br /> Este atributo está asignado por un controlador ODBC *2. x* a la matriz *rgbRowStatus* en una llamada a **SQLExtendedFetch**.|  
|SQL_ATTR_ROWS_FETCHED_PTR (ODBC 3,0)|Un \* valor SQLULEN que señala a un búfer en el que se va a devolver el número de filas recuperadas después de una llamada a **SQLFetch** o **SQLFetchScroll**; el número de filas afectadas por una operación masiva realizada por una llamada a **SQLSetPos** con un argumento de *operación* de SQL_REFRESH; o el número de filas afectadas por una operación masiva realizada por **SQLBulkOperations**. Este número incluye filas de error.<br /><br /> Para obtener más información, vea [número de filas recuperadas y estado](../../../odbc/reference/develop-app/number-of-rows-fetched-and-status.md).<br /><br /> Al establecer este atributo de instrucción, se establece el campo SQL_DESC_ROWS_PROCESSED_PTR en el encabezado IRD.<br /><br /> Si la llamada a **SQLFetch** o **SQLFetchScroll** que rellena el búfer señalado por este atributo no devuelve SQL_SUCCESS ni SQL_SUCCESS_WITH_INFO, el contenido del búfer es indefinido.|  
|SQL_ATTR_SIMULATE_CURSOR (ODBC 2,0)|Un valor SQLULEN que especifica si los controladores que simulan las instrucciones Update y DELETE posicionadas garantizan que dichas instrucciones afecten a una sola fila.<br /><br /> Para simular las instrucciones Update y DELETE posicionadas, la mayoría de los controladores construyen una instrucción **Update** o **Delete** buscada que contiene una cláusula **Where** que especifica el valor de cada columna de la fila actual. A menos que estas columnas contengan una clave única, dicha instrucción puede afectar a más de una fila.<br /><br /> Para garantizar que estas instrucciones solo afecten a una fila, el controlador determina las columnas de una clave única y agrega estas columnas al conjunto de resultados. Si una aplicación garantiza que las columnas del conjunto de resultados componen una clave única, no es necesario que el controlador lo haga. Esto puede reducir el tiempo de ejecución.<br /><br /> SQL_SC_NON_UNIQUE = el controlador no garantiza que las instrucciones UPDATE o DELETE posicionadas solo afecten a una fila; es responsabilidad de la aplicación hacerlo. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**o **SQLSetPos** devuelve SQLSTATE 01001 (conflicto de la operación de cursor).<br /><br /> SQL_SC_TRY_UNIQUE = el controlador intenta garantizar que las instrucciones UPDATE o DELETE posicionadas solo afecten a una fila. El controlador siempre ejecuta estas instrucciones, incluso si pueden afectar a más de una fila, por ejemplo, cuando no hay ninguna clave única. Si una instrucción afecta a más de una fila, **SQLExecute**, **SQLExecDirect**o **SQLSetPos** devuelve SQLSTATE 01001 (conflicto de la operación de cursor).<br /><br /> SQL_SC_UNIQUE = el controlador garantiza que las instrucciones UPDATE o DELETE posicionadas solo afecten a una fila. Si el controlador no puede garantizar esto para una instrucción determinada, **SQLExecDirect** o **SQLPrepare** devuelve un error.<br /><br /> Si el origen de datos proporciona compatibilidad nativa con SQL para las instrucciones Update y DELETE posicionadas y el controlador no simula cursores, se devuelve SQL_SUCCESS cuando se solicita SQL_SC_UNIQUE para SQL_SIMULATE_CURSOR. Se devuelve SQL_SUCCESS_WITH_INFO si se solicita SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Si el origen de datos proporciona el nivel SQL_SC_TRY_UNIQUE de compatibilidad y el controlador no, se devuelve SQL_SUCCESS para SQL_SC_TRY_UNIQUE y SQL_SUCCESS_WITH_INFO se devuelve para SQL_SC_NON_UNIQUE.<br /><br /> Si el origen de datos no admite el tipo de simulación de cursor especificado, el controlador sustituye a un tipo de simulación diferente y devuelve SQLSTATE 01S02 (valor de opción cambiado). Por SQL_SC_UNIQUE, el controlador sustituye, en orden, SQL_SC_TRY_UNIQUE o SQL_SC_NON_UNIQUE. Por SQL_SC_TRY_UNIQUE, el controlador sustituye SQL_SC_NON_UNIQUE.<br /><br /> El valor predeterminado es SQL_SC_UNIQUE.<br /><br /> Para obtener más información, vea [simular instrucciones Update y DELETE posicionadas](../../../odbc/reference/develop-app/simulating-positioned-update-and-delete-statements.md).|  
|SQL_ATTR_USE_BOOKMARKS (ODBC 2,0)|Un valor SQLULEN que especifica si una aplicación usará marcadores con un cursor:<br /><br /> SQL_UB_OFF = OFF (valor predeterminado)<br /><br /> SQL_UB_VARIABLE = una aplicación usará marcadores con un cursor y el controlador proporcionará marcadores de longitud variable si se admiten. SQL_UB_FIXED está en desuso en ODBC *3. x*. Las aplicaciones ODBC *3. x* siempre deben usar marcadores de longitud variable, incluso cuando se trabaja con controladores ODBC *2. x* (que admiten solo marcadores de longitud fija de 4 bytes). Esto se debe a que un marcador de longitud fija es simplemente un caso especial de un marcador de longitud variable. Cuando se trabaja con un controlador ODBC *2. x* , el administrador de controladores asigna SQL_UB_VARIABLE a SQL_UB_FIXED.<br /><br /> Para usar marcadores con un cursor, la aplicación debe especificar este atributo con el valor SQL_UB_VARIABLE antes de abrir el cursor.<br /><br /> Para obtener más información, vea [recuperar marcadores](../../../odbc/reference/develop-app/retrieving-bookmarks.md).|  
  
 [1] solo se puede llamar a estas funciones de forma asincrónica si el descriptor es un descriptor de implementación, no un descriptor de la aplicación.  
  
 Vea enlace de modo de [columna](../../../odbc/reference/develop-app/column-wise-binding.md) y [enlace de modo de fila](../../../odbc/reference/develop-app/row-wise-binding.md).  
  
## <a name="related-functions"></a>Funciones relacionadas  
  
|Para información acerca de|Vea|  
|---------------------------|---------|  
|Cancelar el procesamiento de instrucciones|[Función SQLCancel](../../../odbc/reference/syntax/sqlcancel-function.md)|  
|Devolver el valor de un atributo de conexión|[Función SQLGetConnectAttr](../../../odbc/reference/syntax/sqlgetconnectattr-function.md)|  
|Devolver el valor de un atributo de instrucción|[Función SQLGetStmtAttr](../../../odbc/reference/syntax/sqlgetstmtattr-function.md)|  
|Establecer un atributo de conexión|[Función SQLSetConnectAttr](../../../odbc/reference/syntax/sqlsetconnectattr-function.md)|  
|Establecer un solo campo del descriptor|[Función SQLSetDescField](../../../odbc/reference/syntax/sqlsetdescfield-function.md)|  
  
## <a name="see-also"></a>Vea también  
 [Referencia de la API de ODBC](../../../odbc/reference/syntax/odbc-api-reference.md)   
 [Archivos de encabezado de ODBC](../../../odbc/reference/install/odbc-header-files.md)
